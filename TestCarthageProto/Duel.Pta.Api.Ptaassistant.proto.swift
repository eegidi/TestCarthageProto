// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "PTAAssistant.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Duel { public struct Pta { public struct Api { }}}

public extension Duel.Pta.Api {
  public struct PtaassistantRoot {
    public static let `default` = PtaassistantRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum PtapathType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case typical = 0
    case user = 1
    case realTime = 2
    public func toString() -> String {
      switch self {
      case .typical: return "TYPICAL"
      case .user: return "USER"
      case .realTime: return "REAL_TIME"
      }
    }
    public static func fromString(str:String) throws -> Duel.Pta.Api.PtapathType {
      switch str {
      case "TYPICAL":  return .typical
      case "USER":  return .user
      case "REAL_TIME":  return .realTime
      default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
      switch self {
      case .typical: return ".typical"
      case .user: return ".user"
      case .realTime: return ".realTime"
      }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum DemoMessageType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case report = 0
    case warning = 1
    public func toString() -> String {
      switch self {
      case .report: return "REPORT"
      case .warning: return "WARNING"
      }
    }
    public static func fromString(str:String) throws -> Duel.Pta.Api.DemoMessageType {
      switch str {
      case "REPORT":  return .report
      case "WARNING":  return .warning
      default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
      switch self {
      case .report: return ".report"
      case .warning: return ".warning"
      }
    }
  }

  //Enum type declaration end 

  final public class PtaassistantRequestPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantRequestPb, rhs: Duel.Pta.Api.PtaassistantRequestPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasRequestId == rhs.hasRequestId) && (!lhs.hasRequestId || lhs.requestId == rhs.requestId)
      fieldCheck = fieldCheck && (lhs.hasRequestTime == rhs.hasRequestTime) && (!lhs.hasRequestTime || lhs.requestTime == rhs.requestTime)
      fieldCheck = fieldCheck && (lhs.hasReportType == rhs.hasReportType) && (!lhs.hasReportType || lhs.reportType == rhs.reportType)
      fieldCheck = fieldCheck && (lhs.hasStarLon == rhs.hasStarLon) && (!lhs.hasStarLon || lhs.starLon == rhs.starLon)
      fieldCheck = fieldCheck && (lhs.hasStarLat == rhs.hasStarLat) && (!lhs.hasStarLat || lhs.starLat == rhs.starLat)
      fieldCheck = fieldCheck && (lhs.hasEndLon == rhs.hasEndLon) && (!lhs.hasEndLon || lhs.endLon == rhs.endLon)
      fieldCheck = fieldCheck && (lhs.hasEndLat == rhs.hasEndLat) && (!lhs.hasEndLat || lhs.endLat == rhs.endLat)
      fieldCheck = fieldCheck && (lhs.trajectories == rhs.trajectories)
      fieldCheck = fieldCheck && (lhs.hasTrafficRangeM == rhs.hasTrafficRangeM) && (!lhs.hasTrafficRangeM || lhs.trafficRangeM == rhs.trafficRangeM)
      fieldCheck = fieldCheck && (lhs.hasTrafficRangeS == rhs.hasTrafficRangeS) && (!lhs.hasTrafficRangeS || lhs.trafficRangeS == rhs.trafficRangeS)
      fieldCheck = fieldCheck && (lhs.hasClusterRangeM == rhs.hasClusterRangeM) && (!lhs.hasClusterRangeM || lhs.clusterRangeM == rhs.clusterRangeM)
      fieldCheck = fieldCheck && (lhs.hasClusterRangeS == rhs.hasClusterRangeS) && (!lhs.hasClusterRangeS || lhs.clusterRangeS == rhs.clusterRangeS)
      fieldCheck = fieldCheck && (lhs.hasTrafficThreshold == rhs.hasTrafficThreshold) && (!lhs.hasTrafficThreshold || lhs.trafficThreshold == rhs.trafficThreshold)
      fieldCheck = fieldCheck && (lhs.hasLocale == rhs.hasLocale) && (!lhs.hasLocale || lhs.locale == rhs.locale)
      fieldCheck = fieldCheck && (lhs.hasMinTrafficNewsDelayS == rhs.hasMinTrafficNewsDelayS) && (!lhs.hasMinTrafficNewsDelayS || lhs.minTrafficNewsDelayS == rhs.minTrafficNewsDelayS)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    //id della richiesta
    public fileprivate(set) var requestId:Int32 = Int32(0)
    public fileprivate(set) var hasRequestId:Bool = false

    //timestamp della richiesta
    public fileprivate(set) var requestTime:Int64 = Int64(0)
    public fileprivate(set) var hasRequestTime:Bool = false

    //tipo di richiesta
    public fileprivate(set) var reportType:Int32 = Int32(0)
    public fileprivate(set) var hasReportType:Bool = false

    //longitudine partenza(posizione utente)
    public fileprivate(set) var starLon:Float = Float(0)
    public fileprivate(set) var hasStarLon:Bool = false

    //latitudine partenza(posizione utente)
    public fileprivate(set) var starLat:Float = Float(0)
    public fileprivate(set) var hasStarLat:Bool = false

    //longitudine destinazione
    public fileprivate(set) var endLon:Float = Float(0)
    public fileprivate(set) var hasEndLon:Bool = false

    //latitudine destinazione
    public fileprivate(set) var endLat:Float = Float(0)
    public fileprivate(set) var hasEndLat:Bool = false

    public fileprivate(set) var trajectories:Array<Duel.Pta.Api.PtaassistantTrajectoryPb>  = Array<Duel.Pta.Api.PtaassistantTrajectoryPb>()
    // raggio massimo in metri per il calcolo dei cluster delle notizie di traffico
    public fileprivate(set) var trafficRangeM:Int32 = Int32(0)
    public fileprivate(set) var hasTrafficRangeM:Bool = false

    // raggio massimo in secondi per il calcolo dei cluster delle notizie di traffico
    public fileprivate(set) var trafficRangeS:Int32 = Int32(0)
    public fileprivate(set) var hasTrafficRangeS:Bool = false

    // raggio massimo in metri per l'unione in cluster di due step route
    public fileprivate(set) var clusterRangeM:Int32 = Int32(0)
    public fileprivate(set) var hasClusterRangeM:Bool = false

    // raggio massimo in secondi per l'unione in cluster di due step route
    public fileprivate(set) var clusterRangeS:Int32 = Int32(0)
    public fileprivate(set) var hasClusterRangeS:Bool = false

    // Soglia in percentuale che determina il traffico prevalente in un cluster    
    public fileprivate(set) var trafficThreshold:Float = Float(0)
    public fileprivate(set) var hasTrafficThreshold:Bool = false

    //lang
    public fileprivate(set) var locale:String = ""
    public fileprivate(set) var hasLocale:Bool = false

    // Ritardo minimo accettabile per una situazione di traffico 
    public fileprivate(set) var minTrafficNewsDelayS:Int32 = Int32(0)
    public fileprivate(set) var hasMinTrafficNewsDelayS:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasRequestId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:requestId)
      }
      if hasRequestTime {
        try codedOutputStream.writeInt64(fieldNumber: 2, value:requestTime)
      }
      if hasReportType {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:reportType)
      }
      if hasStarLon {
        try codedOutputStream.writeFloat(fieldNumber: 4, value:starLon)
      }
      if hasStarLat {
        try codedOutputStream.writeFloat(fieldNumber: 5, value:starLat)
      }
      if hasEndLon {
        try codedOutputStream.writeFloat(fieldNumber: 6, value:endLon)
      }
      if hasEndLat {
        try codedOutputStream.writeFloat(fieldNumber: 7, value:endLat)
      }
      for oneElementTrajectories in trajectories {
          try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementTrajectories)
      }
      if hasTrafficRangeM {
        try codedOutputStream.writeInt32(fieldNumber: 9, value:trafficRangeM)
      }
      if hasTrafficRangeS {
        try codedOutputStream.writeInt32(fieldNumber: 10, value:trafficRangeS)
      }
      if hasClusterRangeM {
        try codedOutputStream.writeInt32(fieldNumber: 11, value:clusterRangeM)
      }
      if hasClusterRangeS {
        try codedOutputStream.writeInt32(fieldNumber: 12, value:clusterRangeS)
      }
      if hasTrafficThreshold {
        try codedOutputStream.writeFloat(fieldNumber: 13, value:trafficThreshold)
      }
      if hasLocale {
        try codedOutputStream.writeString(fieldNumber: 14, value:locale)
      }
      if hasMinTrafficNewsDelayS {
        try codedOutputStream.writeInt32(fieldNumber: 15, value:minTrafficNewsDelayS)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasRequestId {
        serialize_size += requestId.computeInt32Size(fieldNumber: 1)
      }
      if hasRequestTime {
        serialize_size += requestTime.computeInt64Size(fieldNumber: 2)
      }
      if hasReportType {
        serialize_size += reportType.computeInt32Size(fieldNumber: 3)
      }
      if hasStarLon {
        serialize_size += starLon.computeFloatSize(fieldNumber: 4)
      }
      if hasStarLat {
        serialize_size += starLat.computeFloatSize(fieldNumber: 5)
      }
      if hasEndLon {
        serialize_size += endLon.computeFloatSize(fieldNumber: 6)
      }
      if hasEndLat {
        serialize_size += endLat.computeFloatSize(fieldNumber: 7)
      }
      for oneElementTrajectories in trajectories {
          serialize_size += oneElementTrajectories.computeMessageSize(fieldNumber: 8)
      }
      if hasTrafficRangeM {
        serialize_size += trafficRangeM.computeInt32Size(fieldNumber: 9)
      }
      if hasTrafficRangeS {
        serialize_size += trafficRangeS.computeInt32Size(fieldNumber: 10)
      }
      if hasClusterRangeM {
        serialize_size += clusterRangeM.computeInt32Size(fieldNumber: 11)
      }
      if hasClusterRangeS {
        serialize_size += clusterRangeS.computeInt32Size(fieldNumber: 12)
      }
      if hasTrafficThreshold {
        serialize_size += trafficThreshold.computeFloatSize(fieldNumber: 13)
      }
      if hasLocale {
        serialize_size += locale.computeStringSize(fieldNumber: 14)
      }
      if hasMinTrafficNewsDelayS {
        serialize_size += minTrafficNewsDelayS.computeInt32Size(fieldNumber: 15)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
      return Duel.Pta.Api.PtaassistantRequestPb.classBuilder() as! Duel.Pta.Api.PtaassistantRequestPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantRequestPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantRequestPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantRequestPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
      return try Duel.Pta.Api.PtaassistantRequestPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantRequestPb) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
      return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasRequestId {
        jsonMap["requestId"] = Int(requestId)
      }
      if hasRequestTime {
        jsonMap["requestTime"] = "\(requestTime)"
      }
      if hasReportType {
        jsonMap["reportType"] = Int(reportType)
      }
      if hasStarLon {
        jsonMap["starLon"] = Float(starLon)
      }
      if hasStarLat {
        jsonMap["starLat"] = Float(starLat)
      }
      if hasEndLon {
        jsonMap["endLon"] = Float(endLon)
      }
      if hasEndLat {
        jsonMap["endLat"] = Float(endLat)
      }
      if !trajectories.isEmpty {
        var jsonArrayTrajectories:Array<Dictionary<String,Any>> = []
          for oneValueTrajectories in trajectories {
            let ecodedMessageTrajectories = try oneValueTrajectories.encode()
            jsonArrayTrajectories.append(ecodedMessageTrajectories)
          }
        jsonMap["trajectories"] = jsonArrayTrajectories
      }
      if hasTrafficRangeM {
        jsonMap["trafficRangeM"] = Int(trafficRangeM)
      }
      if hasTrafficRangeS {
        jsonMap["trafficRangeS"] = Int(trafficRangeS)
      }
      if hasClusterRangeM {
        jsonMap["clusterRangeM"] = Int(clusterRangeM)
      }
      if hasClusterRangeS {
        jsonMap["clusterRangeS"] = Int(clusterRangeS)
      }
      if hasTrafficThreshold {
        jsonMap["trafficThreshold"] = Float(trafficThreshold)
      }
      if hasLocale {
        jsonMap["locale"] = locale
      }
      if hasMinTrafficNewsDelayS {
        jsonMap["minTrafficNewsDelayS"] = Int(minTrafficNewsDelayS)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantRequestPb {
      return try Duel.Pta.Api.PtaassistantRequestPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantRequestPb {
      return try Duel.Pta.Api.PtaassistantRequestPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasRequestId {
        output += "\(indent) requestId: \(requestId) \n"
      }
      if hasRequestTime {
        output += "\(indent) requestTime: \(requestTime) \n"
      }
      if hasReportType {
        output += "\(indent) reportType: \(reportType) \n"
      }
      if hasStarLon {
        output += "\(indent) starLon: \(starLon) \n"
      }
      if hasStarLat {
        output += "\(indent) starLat: \(starLat) \n"
      }
      if hasEndLon {
        output += "\(indent) endLon: \(endLon) \n"
      }
      if hasEndLat {
        output += "\(indent) endLat: \(endLat) \n"
      }
      var trajectoriesElementIndex:Int = 0
      for oneElementTrajectories in trajectories {
          output += "\(indent) trajectories[\(trajectoriesElementIndex)] {\n"
          output += try oneElementTrajectories.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          trajectoriesElementIndex += 1
      }
      if hasTrafficRangeM {
        output += "\(indent) trafficRangeM: \(trafficRangeM) \n"
      }
      if hasTrafficRangeS {
        output += "\(indent) trafficRangeS: \(trafficRangeS) \n"
      }
      if hasClusterRangeM {
        output += "\(indent) clusterRangeM: \(clusterRangeM) \n"
      }
      if hasClusterRangeS {
        output += "\(indent) clusterRangeS: \(clusterRangeS) \n"
      }
      if hasTrafficThreshold {
        output += "\(indent) trafficThreshold: \(trafficThreshold) \n"
      }
      if hasLocale {
        output += "\(indent) locale: \(locale) \n"
      }
      if hasMinTrafficNewsDelayS {
        output += "\(indent) minTrafficNewsDelayS: \(minTrafficNewsDelayS) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasRequestId {
               hashCode = (hashCode &* 31) &+ requestId.hashValue
            }
            if hasRequestTime {
               hashCode = (hashCode &* 31) &+ requestTime.hashValue
            }
            if hasReportType {
               hashCode = (hashCode &* 31) &+ reportType.hashValue
            }
            if hasStarLon {
               hashCode = (hashCode &* 31) &+ starLon.hashValue
            }
            if hasStarLat {
               hashCode = (hashCode &* 31) &+ starLat.hashValue
            }
            if hasEndLon {
               hashCode = (hashCode &* 31) &+ endLon.hashValue
            }
            if hasEndLat {
               hashCode = (hashCode &* 31) &+ endLat.hashValue
            }
            for oneElementTrajectories in trajectories {
                hashCode = (hashCode &* 31) &+ oneElementTrajectories.hashValue
            }
            if hasTrafficRangeM {
               hashCode = (hashCode &* 31) &+ trafficRangeM.hashValue
            }
            if hasTrafficRangeS {
               hashCode = (hashCode &* 31) &+ trafficRangeS.hashValue
            }
            if hasClusterRangeM {
               hashCode = (hashCode &* 31) &+ clusterRangeM.hashValue
            }
            if hasClusterRangeS {
               hashCode = (hashCode &* 31) &+ clusterRangeS.hashValue
            }
            if hasTrafficThreshold {
               hashCode = (hashCode &* 31) &+ trafficThreshold.hashValue
            }
            if hasLocale {
               hashCode = (hashCode &* 31) &+ locale.hashValue
            }
            if hasMinTrafficNewsDelayS {
               hashCode = (hashCode &* 31) &+ minTrafficNewsDelayS.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantRequestPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantRequestPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantRequestPb = Duel.Pta.Api.PtaassistantRequestPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantRequestPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasRequestId:Bool {
           get {
                return builderResult.hasRequestId
           }
      }
      public var requestId:Int32 {
           get {
                return builderResult.requestId
           }
           set (value) {
               builderResult.hasRequestId = true
               builderResult.requestId = value
           }
      }
      @discardableResult
      public func setRequestId(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.requestId = value
        return self
      }
      @discardableResult
      public func clearRequestId() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasRequestId = false
           builderResult.requestId = Int32(0)
           return self
      }
      public var hasRequestTime:Bool {
           get {
                return builderResult.hasRequestTime
           }
      }
      public var requestTime:Int64 {
           get {
                return builderResult.requestTime
           }
           set (value) {
               builderResult.hasRequestTime = true
               builderResult.requestTime = value
           }
      }
      @discardableResult
      public func setRequestTime(_ value:Int64) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.requestTime = value
        return self
      }
      @discardableResult
      public func clearRequestTime() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasRequestTime = false
           builderResult.requestTime = Int64(0)
           return self
      }
      public var hasReportType:Bool {
           get {
                return builderResult.hasReportType
           }
      }
      public var reportType:Int32 {
           get {
                return builderResult.reportType
           }
           set (value) {
               builderResult.hasReportType = true
               builderResult.reportType = value
           }
      }
      @discardableResult
      public func setReportType(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.reportType = value
        return self
      }
      @discardableResult
      public func clearReportType() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasReportType = false
           builderResult.reportType = Int32(0)
           return self
      }
      public var hasStarLon:Bool {
           get {
                return builderResult.hasStarLon
           }
      }
      public var starLon:Float {
           get {
                return builderResult.starLon
           }
           set (value) {
               builderResult.hasStarLon = true
               builderResult.starLon = value
           }
      }
      @discardableResult
      public func setStarLon(_ value:Float) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.starLon = value
        return self
      }
      @discardableResult
      public func clearStarLon() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasStarLon = false
           builderResult.starLon = Float(0)
           return self
      }
      public var hasStarLat:Bool {
           get {
                return builderResult.hasStarLat
           }
      }
      public var starLat:Float {
           get {
                return builderResult.starLat
           }
           set (value) {
               builderResult.hasStarLat = true
               builderResult.starLat = value
           }
      }
      @discardableResult
      public func setStarLat(_ value:Float) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.starLat = value
        return self
      }
      @discardableResult
      public func clearStarLat() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasStarLat = false
           builderResult.starLat = Float(0)
           return self
      }
      public var hasEndLon:Bool {
           get {
                return builderResult.hasEndLon
           }
      }
      public var endLon:Float {
           get {
                return builderResult.endLon
           }
           set (value) {
               builderResult.hasEndLon = true
               builderResult.endLon = value
           }
      }
      @discardableResult
      public func setEndLon(_ value:Float) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.endLon = value
        return self
      }
      @discardableResult
      public func clearEndLon() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasEndLon = false
           builderResult.endLon = Float(0)
           return self
      }
      public var hasEndLat:Bool {
           get {
                return builderResult.hasEndLat
           }
      }
      public var endLat:Float {
           get {
                return builderResult.endLat
           }
           set (value) {
               builderResult.hasEndLat = true
               builderResult.endLat = value
           }
      }
      @discardableResult
      public func setEndLat(_ value:Float) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.endLat = value
        return self
      }
      @discardableResult
      public func clearEndLat() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasEndLat = false
           builderResult.endLat = Float(0)
           return self
      }
      public var trajectories:Array<Duel.Pta.Api.PtaassistantTrajectoryPb> {
           get {
               return builderResult.trajectories
           }
           set (value) {
               builderResult.trajectories = value
           }
      }
      @discardableResult
      public func setTrajectories(_ value:Array<Duel.Pta.Api.PtaassistantTrajectoryPb>) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.trajectories = value
        return self
      }
      @discardableResult
      public func clearTrajectories() -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        builderResult.trajectories.removeAll(keepingCapacity: false)
        return self
      }
      public var hasTrafficRangeM:Bool {
           get {
                return builderResult.hasTrafficRangeM
           }
      }
      public var trafficRangeM:Int32 {
           get {
                return builderResult.trafficRangeM
           }
           set (value) {
               builderResult.hasTrafficRangeM = true
               builderResult.trafficRangeM = value
           }
      }
      @discardableResult
      public func setTrafficRangeM(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.trafficRangeM = value
        return self
      }
      @discardableResult
      public func clearTrafficRangeM() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasTrafficRangeM = false
           builderResult.trafficRangeM = Int32(0)
           return self
      }
      public var hasTrafficRangeS:Bool {
           get {
                return builderResult.hasTrafficRangeS
           }
      }
      public var trafficRangeS:Int32 {
           get {
                return builderResult.trafficRangeS
           }
           set (value) {
               builderResult.hasTrafficRangeS = true
               builderResult.trafficRangeS = value
           }
      }
      @discardableResult
      public func setTrafficRangeS(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.trafficRangeS = value
        return self
      }
      @discardableResult
      public func clearTrafficRangeS() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasTrafficRangeS = false
           builderResult.trafficRangeS = Int32(0)
           return self
      }
      public var hasClusterRangeM:Bool {
           get {
                return builderResult.hasClusterRangeM
           }
      }
      public var clusterRangeM:Int32 {
           get {
                return builderResult.clusterRangeM
           }
           set (value) {
               builderResult.hasClusterRangeM = true
               builderResult.clusterRangeM = value
           }
      }
      @discardableResult
      public func setClusterRangeM(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.clusterRangeM = value
        return self
      }
      @discardableResult
      public func clearClusterRangeM() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasClusterRangeM = false
           builderResult.clusterRangeM = Int32(0)
           return self
      }
      public var hasClusterRangeS:Bool {
           get {
                return builderResult.hasClusterRangeS
           }
      }
      public var clusterRangeS:Int32 {
           get {
                return builderResult.clusterRangeS
           }
           set (value) {
               builderResult.hasClusterRangeS = true
               builderResult.clusterRangeS = value
           }
      }
      @discardableResult
      public func setClusterRangeS(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.clusterRangeS = value
        return self
      }
      @discardableResult
      public func clearClusterRangeS() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasClusterRangeS = false
           builderResult.clusterRangeS = Int32(0)
           return self
      }
      public var hasTrafficThreshold:Bool {
           get {
                return builderResult.hasTrafficThreshold
           }
      }
      public var trafficThreshold:Float {
           get {
                return builderResult.trafficThreshold
           }
           set (value) {
               builderResult.hasTrafficThreshold = true
               builderResult.trafficThreshold = value
           }
      }
      @discardableResult
      public func setTrafficThreshold(_ value:Float) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.trafficThreshold = value
        return self
      }
      @discardableResult
      public func clearTrafficThreshold() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasTrafficThreshold = false
           builderResult.trafficThreshold = Float(0)
           return self
      }
      public var hasLocale:Bool {
           get {
                return builderResult.hasLocale
           }
      }
      public var locale:String {
           get {
                return builderResult.locale
           }
           set (value) {
               builderResult.hasLocale = true
               builderResult.locale = value
           }
      }
      @discardableResult
      public func setLocale(_ value:String) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.locale = value
        return self
      }
      @discardableResult
      public func clearLocale() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasLocale = false
           builderResult.locale = ""
           return self
      }
      public var hasMinTrafficNewsDelayS:Bool {
           get {
                return builderResult.hasMinTrafficNewsDelayS
           }
      }
      public var minTrafficNewsDelayS:Int32 {
           get {
                return builderResult.minTrafficNewsDelayS
           }
           set (value) {
               builderResult.hasMinTrafficNewsDelayS = true
               builderResult.minTrafficNewsDelayS = value
           }
      }
      @discardableResult
      public func setMinTrafficNewsDelayS(_ value:Int32) -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        self.minTrafficNewsDelayS = value
        return self
      }
      @discardableResult
      public func clearMinTrafficNewsDelayS() -> Duel.Pta.Api.PtaassistantRequestPb.Builder{
           builderResult.hasMinTrafficNewsDelayS = false
           builderResult.minTrafficNewsDelayS = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantRequestPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        return try Duel.Pta.Api.PtaassistantRequestPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantRequestPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantRequestPb {
        let returnMe:Duel.Pta.Api.PtaassistantRequestPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantRequestPb) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        if other == Duel.Pta.Api.PtaassistantRequestPb() {
         return self
        }
        if other.hasRequestId {
             requestId = other.requestId
        }
        if other.hasRequestTime {
             requestTime = other.requestTime
        }
        if other.hasReportType {
             reportType = other.reportType
        }
        if other.hasStarLon {
             starLon = other.starLon
        }
        if other.hasStarLat {
             starLat = other.starLat
        }
        if other.hasEndLon {
             endLon = other.endLon
        }
        if other.hasEndLat {
             endLat = other.endLat
        }
        if !other.trajectories.isEmpty  {
           builderResult.trajectories += other.trajectories
        }
        if other.hasTrafficRangeM {
             trafficRangeM = other.trafficRangeM
        }
        if other.hasTrafficRangeS {
             trafficRangeS = other.trafficRangeS
        }
        if other.hasClusterRangeM {
             clusterRangeM = other.clusterRangeM
        }
        if other.hasClusterRangeS {
             clusterRangeS = other.clusterRangeS
        }
        if other.hasTrafficThreshold {
             trafficThreshold = other.trafficThreshold
        }
        if other.hasLocale {
             locale = other.locale
        }
        if other.hasMinTrafficNewsDelayS {
             minTrafficNewsDelayS = other.minTrafficNewsDelayS
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            requestId = try codedInputStream.readInt32()

          case 16:
            requestTime = try codedInputStream.readInt64()

          case 24:
            reportType = try codedInputStream.readInt32()

          case 37:
            starLon = try codedInputStream.readFloat()

          case 45:
            starLat = try codedInputStream.readFloat()

          case 53:
            endLon = try codedInputStream.readFloat()

          case 61:
            endLat = try codedInputStream.readFloat()

          case 66:
            let subBuilder = Duel.Pta.Api.PtaassistantTrajectoryPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            trajectories.append(subBuilder.buildPartial())

          case 72:
            trafficRangeM = try codedInputStream.readInt32()

          case 80:
            trafficRangeS = try codedInputStream.readInt32()

          case 88:
            clusterRangeM = try codedInputStream.readInt32()

          case 96:
            clusterRangeS = try codedInputStream.readInt32()

          case 109:
            trafficThreshold = try codedInputStream.readFloat()

          case 114:
            locale = try codedInputStream.readString()

          case 120:
            minTrafficNewsDelayS = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantRequestPb.Builder()
        if let jsonValueRequestId = jsonMap["requestId"] as? Int {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)
        } else if let jsonValueRequestId = jsonMap["requestId"] as? String {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)!
        }
        if let jsonValueRequestTime = jsonMap["requestTime"] as? String {
          resultDecodedBuilder.requestTime = Int64(jsonValueRequestTime)!
        } else if let jsonValueRequestTime = jsonMap["requestTime"] as? Int {
          resultDecodedBuilder.requestTime = Int64(jsonValueRequestTime)
        }
        if let jsonValueReportType = jsonMap["reportType"] as? Int {
          resultDecodedBuilder.reportType = Int32(jsonValueReportType)
        } else if let jsonValueReportType = jsonMap["reportType"] as? String {
          resultDecodedBuilder.reportType = Int32(jsonValueReportType)!
        }
        if let jsonValueStarLon = jsonMap["starLon"] as? Float {
          resultDecodedBuilder.starLon = Float(jsonValueStarLon)
        } else if let jsonValueStarLon = jsonMap["starLon"] as? String {
          resultDecodedBuilder.starLon = Float(jsonValueStarLon)!
        }
        if let jsonValueStarLat = jsonMap["starLat"] as? Float {
          resultDecodedBuilder.starLat = Float(jsonValueStarLat)
        } else if let jsonValueStarLat = jsonMap["starLat"] as? String {
          resultDecodedBuilder.starLat = Float(jsonValueStarLat)!
        }
        if let jsonValueEndLon = jsonMap["endLon"] as? Float {
          resultDecodedBuilder.endLon = Float(jsonValueEndLon)
        } else if let jsonValueEndLon = jsonMap["endLon"] as? String {
          resultDecodedBuilder.endLon = Float(jsonValueEndLon)!
        }
        if let jsonValueEndLat = jsonMap["endLat"] as? Float {
          resultDecodedBuilder.endLat = Float(jsonValueEndLat)
        } else if let jsonValueEndLat = jsonMap["endLat"] as? String {
          resultDecodedBuilder.endLat = Float(jsonValueEndLat)!
        }
        if let jsonValueTrajectories = jsonMap["trajectories"] as? Array<Dictionary<String,Any>> {
          var jsonArrayTrajectories:Array<Duel.Pta.Api.PtaassistantTrajectoryPb> = []
          for oneValueTrajectories in jsonValueTrajectories {
            let messageFromStringTrajectories = try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder.decodeToBuilder(jsonMap:oneValueTrajectories).build()

            jsonArrayTrajectories.append(messageFromStringTrajectories)
          }
          resultDecodedBuilder.trajectories = jsonArrayTrajectories
        }
        if let jsonValueTrafficRangeM = jsonMap["trafficRangeM"] as? Int {
          resultDecodedBuilder.trafficRangeM = Int32(jsonValueTrafficRangeM)
        } else if let jsonValueTrafficRangeM = jsonMap["trafficRangeM"] as? String {
          resultDecodedBuilder.trafficRangeM = Int32(jsonValueTrafficRangeM)!
        }
        if let jsonValueTrafficRangeS = jsonMap["trafficRangeS"] as? Int {
          resultDecodedBuilder.trafficRangeS = Int32(jsonValueTrafficRangeS)
        } else if let jsonValueTrafficRangeS = jsonMap["trafficRangeS"] as? String {
          resultDecodedBuilder.trafficRangeS = Int32(jsonValueTrafficRangeS)!
        }
        if let jsonValueClusterRangeM = jsonMap["clusterRangeM"] as? Int {
          resultDecodedBuilder.clusterRangeM = Int32(jsonValueClusterRangeM)
        } else if let jsonValueClusterRangeM = jsonMap["clusterRangeM"] as? String {
          resultDecodedBuilder.clusterRangeM = Int32(jsonValueClusterRangeM)!
        }
        if let jsonValueClusterRangeS = jsonMap["clusterRangeS"] as? Int {
          resultDecodedBuilder.clusterRangeS = Int32(jsonValueClusterRangeS)
        } else if let jsonValueClusterRangeS = jsonMap["clusterRangeS"] as? String {
          resultDecodedBuilder.clusterRangeS = Int32(jsonValueClusterRangeS)!
        }
        if let jsonValueTrafficThreshold = jsonMap["trafficThreshold"] as? Float {
          resultDecodedBuilder.trafficThreshold = Float(jsonValueTrafficThreshold)
        } else if let jsonValueTrafficThreshold = jsonMap["trafficThreshold"] as? String {
          resultDecodedBuilder.trafficThreshold = Float(jsonValueTrafficThreshold)!
        }
        if let jsonValueLocale = jsonMap["locale"] as? String {
          resultDecodedBuilder.locale = jsonValueLocale
        }
        if let jsonValueMinTrafficNewsDelayS = jsonMap["minTrafficNewsDelayS"] as? Int {
          resultDecodedBuilder.minTrafficNewsDelayS = Int32(jsonValueMinTrafficNewsDelayS)
        } else if let jsonValueMinTrafficNewsDelayS = jsonMap["minTrafficNewsDelayS"] as? String {
          resultDecodedBuilder.minTrafficNewsDelayS = Int32(jsonValueMinTrafficNewsDelayS)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantRequestPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantRequestPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantTrajectoryPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantTrajectoryPb, rhs: Duel.Pta.Api.PtaassistantTrajectoryPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasTrajectoryId == rhs.hasTrajectoryId) && (!lhs.hasTrajectoryId || lhs.trajectoryId == rhs.trajectoryId)
      fieldCheck = fieldCheck && (lhs.pointsDeg == rhs.pointsDeg)
      fieldCheck = fieldCheck && (lhs.hasTravelTimeMs == rhs.hasTravelTimeMs) && (!lhs.hasTravelTimeMs || lhs.travelTimeMs == rhs.travelTimeMs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    //< Suggested path id
    public fileprivate(set) var trajectoryId:Int32 = Int32(0)
    public fileprivate(set) var hasTrajectoryId:Bool = false

    //< Coordinates of the trajectory <longitude, latitude>
    public fileprivate(set) var pointsDeg:Array<Float> = Array<Float>()
    private var pointsDegMemoizedSerializedSize:Int32 = -1
    //< Travel time in ms for the trajectory
    public fileprivate(set) var travelTimeMs:UInt64 = UInt64(0)
    public fileprivate(set) var hasTravelTimeMs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasTrajectoryId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:trajectoryId)
      }
      if !pointsDeg.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 18)
        try codedOutputStream.writeRawVarint32(value: pointsDegMemoizedSerializedSize)
        for oneValuepointsDeg in pointsDeg {
          try codedOutputStream.writeFloatNoTag(value: oneValuepointsDeg)
        }
      }
      if hasTravelTimeMs {
        try codedOutputStream.writeUInt64(fieldNumber: 3, value:travelTimeMs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTrajectoryId {
        serialize_size += trajectoryId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizePointsDeg:Int32 = 0
      dataSizePointsDeg = 4 * Int32(pointsDeg.count)
      serialize_size += dataSizePointsDeg
      if !pointsDeg.isEmpty {
        serialize_size += 1
        serialize_size += dataSizePointsDeg.computeInt32SizeNoTag()
      }
      pointsDegMemoizedSerializedSize = dataSizePointsDeg
      if hasTravelTimeMs {
        serialize_size += travelTimeMs.computeUInt64Size(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
      return Duel.Pta.Api.PtaassistantTrajectoryPb.classBuilder() as! Duel.Pta.Api.PtaassistantTrajectoryPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantTrajectoryPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantTrajectoryPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantTrajectoryPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
      return try Duel.Pta.Api.PtaassistantTrajectoryPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantTrajectoryPb) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
      return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasTrajectoryId {
        jsonMap["trajectoryId"] = Int(trajectoryId)
      }
      if !pointsDeg.isEmpty {
        var jsonArrayPointsDeg:Array<Float> = []
          for oneValuePointsDeg in pointsDeg {
            jsonArrayPointsDeg.append(Float(oneValuePointsDeg))
          }
        jsonMap["pointsDeg"] = jsonArrayPointsDeg
      }
      if hasTravelTimeMs {
        jsonMap["travelTimeMs"] = "\(travelTimeMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
      return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
      return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasTrajectoryId {
        output += "\(indent) trajectoryId: \(trajectoryId) \n"
      }
      var pointsDegElementIndex:Int = 0
      for oneValuePointsDeg in pointsDeg  {
          output += "\(indent) pointsDeg[\(pointsDegElementIndex)]: \(oneValuePointsDeg)\n"
          pointsDegElementIndex += 1
      }
      if hasTravelTimeMs {
        output += "\(indent) travelTimeMs: \(travelTimeMs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTrajectoryId {
               hashCode = (hashCode &* 31) &+ trajectoryId.hashValue
            }
            for oneValuePointsDeg in pointsDeg {
                hashCode = (hashCode &* 31) &+ oneValuePointsDeg.hashValue
            }
            if hasTravelTimeMs {
               hashCode = (hashCode &* 31) &+ travelTimeMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantTrajectoryPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantTrajectoryPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantTrajectoryPb = Duel.Pta.Api.PtaassistantTrajectoryPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantTrajectoryPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTrajectoryId:Bool {
           get {
                return builderResult.hasTrajectoryId
           }
      }
      public var trajectoryId:Int32 {
           get {
                return builderResult.trajectoryId
           }
           set (value) {
               builderResult.hasTrajectoryId = true
               builderResult.trajectoryId = value
           }
      }
      @discardableResult
      public func setTrajectoryId(_ value:Int32) -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        self.trajectoryId = value
        return self
      }
      @discardableResult
      public func clearTrajectoryId() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder{
           builderResult.hasTrajectoryId = false
           builderResult.trajectoryId = Int32(0)
           return self
      }
      public var pointsDeg:Array<Float> {
           get {
               return builderResult.pointsDeg
           }
           set (array) {
               builderResult.pointsDeg = array
           }
      }
      @discardableResult
      public func setPointsDeg(_ value:Array<Float>) -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        self.pointsDeg = value
        return self
      }
      @discardableResult
      public func clearPointsDeg() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
         builderResult.pointsDeg.removeAll(keepingCapacity: false)
         return self
      }
      public var hasTravelTimeMs:Bool {
           get {
                return builderResult.hasTravelTimeMs
           }
      }
      public var travelTimeMs:UInt64 {
           get {
                return builderResult.travelTimeMs
           }
           set (value) {
               builderResult.hasTravelTimeMs = true
               builderResult.travelTimeMs = value
           }
      }
      @discardableResult
      public func setTravelTimeMs(_ value:UInt64) -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        self.travelTimeMs = value
        return self
      }
      @discardableResult
      public func clearTravelTimeMs() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder{
           builderResult.hasTravelTimeMs = false
           builderResult.travelTimeMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantTrajectoryPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        return try Duel.Pta.Api.PtaassistantTrajectoryPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantTrajectoryPb {
        let returnMe:Duel.Pta.Api.PtaassistantTrajectoryPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantTrajectoryPb) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        if other == Duel.Pta.Api.PtaassistantTrajectoryPb() {
         return self
        }
        if other.hasTrajectoryId {
             trajectoryId = other.trajectoryId
        }
        if !other.pointsDeg.isEmpty {
            builderResult.pointsDeg += other.pointsDeg
        }
        if other.hasTravelTimeMs {
             travelTimeMs = other.travelTimeMs
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            trajectoryId = try codedInputStream.readInt32()

          case 18:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.pointsDeg.append(try codedInputStream.readFloat())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 24:
            travelTimeMs = try codedInputStream.readUInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantTrajectoryPb.Builder()
        if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? Int {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)
        } else if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? String {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)!
        }
        if let jsonValuePointsDeg = jsonMap["pointsDeg"] as? Array<Float> {
          var jsonArrayPointsDeg:Array<Float> = []
          for oneValuePointsDeg in jsonValuePointsDeg {
            jsonArrayPointsDeg.append(Float(oneValuePointsDeg))
          }
          resultDecodedBuilder.pointsDeg = jsonArrayPointsDeg
        }
        if let jsonValueTravelTimeMs = jsonMap["travelTimeMs"] as? String {
          resultDecodedBuilder.travelTimeMs = UInt64(jsonValueTravelTimeMs)!
        } else if let jsonValueTravelTimeMs = jsonMap["travelTimeMs"] as? UInt {
          resultDecodedBuilder.travelTimeMs = UInt64(jsonValueTravelTimeMs)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantResponsePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantResponsePb, rhs: Duel.Pta.Api.PtaassistantResponsePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasRequestId == rhs.hasRequestId) && (!lhs.hasRequestId || lhs.requestId == rhs.requestId)
      fieldCheck = fieldCheck && (lhs.hasRequestTime == rhs.hasRequestTime) && (!lhs.hasRequestTime || lhs.requestTime == rhs.requestTime)
      fieldCheck = fieldCheck && (lhs.hasReportType == rhs.hasReportType) && (!lhs.hasReportType || lhs.reportType == rhs.reportType)
      fieldCheck = fieldCheck && (lhs.segments == rhs.segments)
      fieldCheck = fieldCheck && (lhs.edges == rhs.edges)
      fieldCheck = fieldCheck && (lhs.losEvents == rhs.losEvents)
      fieldCheck = fieldCheck && (lhs.events == rhs.events)
      fieldCheck = fieldCheck && (lhs.nodes == rhs.nodes)
      fieldCheck = fieldCheck && (lhs.paths == rhs.paths)
      fieldCheck = fieldCheck && (lhs.hasStartNodeId == rhs.hasStartNodeId) && (!lhs.hasStartNodeId || lhs.startNodeId == rhs.startNodeId)
      fieldCheck = fieldCheck && (lhs.hasEndNodeId == rhs.hasEndNodeId) && (!lhs.hasEndNodeId || lhs.endNodeId == rhs.endNodeId)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    //id della richiesta
    public fileprivate(set) var requestId:Int32 = Int32(0)
    public fileprivate(set) var hasRequestId:Bool = false

    //timestamp della richiesta
    public fileprivate(set) var requestTime:Int64 = Int64(0)
    public fileprivate(set) var hasRequestTime:Bool = false

    //tipo di richiesta
    public fileprivate(set) var reportType:Int32 = Int32(0)
    public fileprivate(set) var hasReportType:Bool = false

    public fileprivate(set) var segments:Array<Duel.Pta.Api.PtaassistantSegmentPb>  = Array<Duel.Pta.Api.PtaassistantSegmentPb>()
    public fileprivate(set) var edges:Array<Duel.Pta.Api.PtaassistantEdgePb>  = Array<Duel.Pta.Api.PtaassistantEdgePb>()
    public fileprivate(set) var losEvents:Array<Duel.Pta.Api.PtaassistantLosEventPb>  = Array<Duel.Pta.Api.PtaassistantLosEventPb>()
    public fileprivate(set) var events:Array<Duel.Pta.Api.PtaassistantEventPb>  = Array<Duel.Pta.Api.PtaassistantEventPb>()
    public fileprivate(set) var nodes:Array<Duel.Pta.Api.PtaassistantNodePb>  = Array<Duel.Pta.Api.PtaassistantNodePb>()
    public fileprivate(set) var paths:Array<Duel.Pta.Api.PtaassistantPathPb>  = Array<Duel.Pta.Api.PtaassistantPathPb>()
    //id nodo iniziale
    public fileprivate(set) var startNodeId:Int32 = Int32(0)
    public fileprivate(set) var hasStartNodeId:Bool = false

    //id nodo finale
    public fileprivate(set) var endNodeId:Int32 = Int32(0)
    public fileprivate(set) var hasEndNodeId:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasRequestId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:requestId)
      }
      if hasRequestTime {
        try codedOutputStream.writeInt64(fieldNumber: 2, value:requestTime)
      }
      if hasReportType {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:reportType)
      }
      for oneElementSegments in segments {
          try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementSegments)
      }
      for oneElementEdges in edges {
          try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementEdges)
      }
      for oneElementLosEvents in losEvents {
          try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementLosEvents)
      }
      for oneElementEvents in events {
          try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementEvents)
      }
      for oneElementNodes in nodes {
          try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementNodes)
      }
      for oneElementPaths in paths {
          try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementPaths)
      }
      if hasStartNodeId {
        try codedOutputStream.writeInt32(fieldNumber: 10, value:startNodeId)
      }
      if hasEndNodeId {
        try codedOutputStream.writeInt32(fieldNumber: 11, value:endNodeId)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasRequestId {
        serialize_size += requestId.computeInt32Size(fieldNumber: 1)
      }
      if hasRequestTime {
        serialize_size += requestTime.computeInt64Size(fieldNumber: 2)
      }
      if hasReportType {
        serialize_size += reportType.computeInt32Size(fieldNumber: 3)
      }
      for oneElementSegments in segments {
          serialize_size += oneElementSegments.computeMessageSize(fieldNumber: 4)
      }
      for oneElementEdges in edges {
          serialize_size += oneElementEdges.computeMessageSize(fieldNumber: 5)
      }
      for oneElementLosEvents in losEvents {
          serialize_size += oneElementLosEvents.computeMessageSize(fieldNumber: 6)
      }
      for oneElementEvents in events {
          serialize_size += oneElementEvents.computeMessageSize(fieldNumber: 7)
      }
      for oneElementNodes in nodes {
          serialize_size += oneElementNodes.computeMessageSize(fieldNumber: 8)
      }
      for oneElementPaths in paths {
          serialize_size += oneElementPaths.computeMessageSize(fieldNumber: 9)
      }
      if hasStartNodeId {
        serialize_size += startNodeId.computeInt32Size(fieldNumber: 10)
      }
      if hasEndNodeId {
        serialize_size += endNodeId.computeInt32Size(fieldNumber: 11)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
      return Duel.Pta.Api.PtaassistantResponsePb.classBuilder() as! Duel.Pta.Api.PtaassistantResponsePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantResponsePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantResponsePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantResponsePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantResponsePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantResponsePb) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasRequestId {
        jsonMap["requestId"] = Int(requestId)
      }
      if hasRequestTime {
        jsonMap["requestTime"] = "\(requestTime)"
      }
      if hasReportType {
        jsonMap["reportType"] = Int(reportType)
      }
      if !segments.isEmpty {
        var jsonArraySegments:Array<Dictionary<String,Any>> = []
          for oneValueSegments in segments {
            let ecodedMessageSegments = try oneValueSegments.encode()
            jsonArraySegments.append(ecodedMessageSegments)
          }
        jsonMap["segments"] = jsonArraySegments
      }
      if !edges.isEmpty {
        var jsonArrayEdges:Array<Dictionary<String,Any>> = []
          for oneValueEdges in edges {
            let ecodedMessageEdges = try oneValueEdges.encode()
            jsonArrayEdges.append(ecodedMessageEdges)
          }
        jsonMap["edges"] = jsonArrayEdges
      }
      if !losEvents.isEmpty {
        var jsonArrayLosEvents:Array<Dictionary<String,Any>> = []
          for oneValueLosEvents in losEvents {
            let ecodedMessageLosEvents = try oneValueLosEvents.encode()
            jsonArrayLosEvents.append(ecodedMessageLosEvents)
          }
        jsonMap["losEvents"] = jsonArrayLosEvents
      }
      if !events.isEmpty {
        var jsonArrayEvents:Array<Dictionary<String,Any>> = []
          for oneValueEvents in events {
            let ecodedMessageEvents = try oneValueEvents.encode()
            jsonArrayEvents.append(ecodedMessageEvents)
          }
        jsonMap["events"] = jsonArrayEvents
      }
      if !nodes.isEmpty {
        var jsonArrayNodes:Array<Dictionary<String,Any>> = []
          for oneValueNodes in nodes {
            let ecodedMessageNodes = try oneValueNodes.encode()
            jsonArrayNodes.append(ecodedMessageNodes)
          }
        jsonMap["nodes"] = jsonArrayNodes
      }
      if !paths.isEmpty {
        var jsonArrayPaths:Array<Dictionary<String,Any>> = []
          for oneValuePaths in paths {
            let ecodedMessagePaths = try oneValuePaths.encode()
            jsonArrayPaths.append(ecodedMessagePaths)
          }
        jsonMap["paths"] = jsonArrayPaths
      }
      if hasStartNodeId {
        jsonMap["startNodeId"] = Int(startNodeId)
      }
      if hasEndNodeId {
        jsonMap["endNodeId"] = Int(endNodeId)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantResponsePb {
      return try Duel.Pta.Api.PtaassistantResponsePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantResponsePb {
      return try Duel.Pta.Api.PtaassistantResponsePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasRequestId {
        output += "\(indent) requestId: \(requestId) \n"
      }
      if hasRequestTime {
        output += "\(indent) requestTime: \(requestTime) \n"
      }
      if hasReportType {
        output += "\(indent) reportType: \(reportType) \n"
      }
      var segmentsElementIndex:Int = 0
      for oneElementSegments in segments {
          output += "\(indent) segments[\(segmentsElementIndex)] {\n"
          output += try oneElementSegments.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          segmentsElementIndex += 1
      }
      var edgesElementIndex:Int = 0
      for oneElementEdges in edges {
          output += "\(indent) edges[\(edgesElementIndex)] {\n"
          output += try oneElementEdges.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          edgesElementIndex += 1
      }
      var losEventsElementIndex:Int = 0
      for oneElementLosEvents in losEvents {
          output += "\(indent) losEvents[\(losEventsElementIndex)] {\n"
          output += try oneElementLosEvents.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          losEventsElementIndex += 1
      }
      var eventsElementIndex:Int = 0
      for oneElementEvents in events {
          output += "\(indent) events[\(eventsElementIndex)] {\n"
          output += try oneElementEvents.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          eventsElementIndex += 1
      }
      var nodesElementIndex:Int = 0
      for oneElementNodes in nodes {
          output += "\(indent) nodes[\(nodesElementIndex)] {\n"
          output += try oneElementNodes.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          nodesElementIndex += 1
      }
      var pathsElementIndex:Int = 0
      for oneElementPaths in paths {
          output += "\(indent) paths[\(pathsElementIndex)] {\n"
          output += try oneElementPaths.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          pathsElementIndex += 1
      }
      if hasStartNodeId {
        output += "\(indent) startNodeId: \(startNodeId) \n"
      }
      if hasEndNodeId {
        output += "\(indent) endNodeId: \(endNodeId) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasRequestId {
               hashCode = (hashCode &* 31) &+ requestId.hashValue
            }
            if hasRequestTime {
               hashCode = (hashCode &* 31) &+ requestTime.hashValue
            }
            if hasReportType {
               hashCode = (hashCode &* 31) &+ reportType.hashValue
            }
            for oneElementSegments in segments {
                hashCode = (hashCode &* 31) &+ oneElementSegments.hashValue
            }
            for oneElementEdges in edges {
                hashCode = (hashCode &* 31) &+ oneElementEdges.hashValue
            }
            for oneElementLosEvents in losEvents {
                hashCode = (hashCode &* 31) &+ oneElementLosEvents.hashValue
            }
            for oneElementEvents in events {
                hashCode = (hashCode &* 31) &+ oneElementEvents.hashValue
            }
            for oneElementNodes in nodes {
                hashCode = (hashCode &* 31) &+ oneElementNodes.hashValue
            }
            for oneElementPaths in paths {
                hashCode = (hashCode &* 31) &+ oneElementPaths.hashValue
            }
            if hasStartNodeId {
               hashCode = (hashCode &* 31) &+ startNodeId.hashValue
            }
            if hasEndNodeId {
               hashCode = (hashCode &* 31) &+ endNodeId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantResponsePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantResponsePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantResponsePb = Duel.Pta.Api.PtaassistantResponsePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantResponsePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasRequestId:Bool {
           get {
                return builderResult.hasRequestId
           }
      }
      public var requestId:Int32 {
           get {
                return builderResult.requestId
           }
           set (value) {
               builderResult.hasRequestId = true
               builderResult.requestId = value
           }
      }
      @discardableResult
      public func setRequestId(_ value:Int32) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.requestId = value
        return self
      }
      @discardableResult
      public func clearRequestId() -> Duel.Pta.Api.PtaassistantResponsePb.Builder{
           builderResult.hasRequestId = false
           builderResult.requestId = Int32(0)
           return self
      }
      public var hasRequestTime:Bool {
           get {
                return builderResult.hasRequestTime
           }
      }
      public var requestTime:Int64 {
           get {
                return builderResult.requestTime
           }
           set (value) {
               builderResult.hasRequestTime = true
               builderResult.requestTime = value
           }
      }
      @discardableResult
      public func setRequestTime(_ value:Int64) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.requestTime = value
        return self
      }
      @discardableResult
      public func clearRequestTime() -> Duel.Pta.Api.PtaassistantResponsePb.Builder{
           builderResult.hasRequestTime = false
           builderResult.requestTime = Int64(0)
           return self
      }
      public var hasReportType:Bool {
           get {
                return builderResult.hasReportType
           }
      }
      public var reportType:Int32 {
           get {
                return builderResult.reportType
           }
           set (value) {
               builderResult.hasReportType = true
               builderResult.reportType = value
           }
      }
      @discardableResult
      public func setReportType(_ value:Int32) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.reportType = value
        return self
      }
      @discardableResult
      public func clearReportType() -> Duel.Pta.Api.PtaassistantResponsePb.Builder{
           builderResult.hasReportType = false
           builderResult.reportType = Int32(0)
           return self
      }
      public var segments:Array<Duel.Pta.Api.PtaassistantSegmentPb> {
           get {
               return builderResult.segments
           }
           set (value) {
               builderResult.segments = value
           }
      }
      @discardableResult
      public func setSegments(_ value:Array<Duel.Pta.Api.PtaassistantSegmentPb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.segments = value
        return self
      }
      @discardableResult
      public func clearSegments() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.segments.removeAll(keepingCapacity: false)
        return self
      }
      public var edges:Array<Duel.Pta.Api.PtaassistantEdgePb> {
           get {
               return builderResult.edges
           }
           set (value) {
               builderResult.edges = value
           }
      }
      @discardableResult
      public func setEdges(_ value:Array<Duel.Pta.Api.PtaassistantEdgePb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.edges = value
        return self
      }
      @discardableResult
      public func clearEdges() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.edges.removeAll(keepingCapacity: false)
        return self
      }
      public var losEvents:Array<Duel.Pta.Api.PtaassistantLosEventPb> {
           get {
               return builderResult.losEvents
           }
           set (value) {
               builderResult.losEvents = value
           }
      }
      @discardableResult
      public func setLosEvents(_ value:Array<Duel.Pta.Api.PtaassistantLosEventPb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.losEvents = value
        return self
      }
      @discardableResult
      public func clearLosEvents() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.losEvents.removeAll(keepingCapacity: false)
        return self
      }
      public var events:Array<Duel.Pta.Api.PtaassistantEventPb> {
           get {
               return builderResult.events
           }
           set (value) {
               builderResult.events = value
           }
      }
      @discardableResult
      public func setEvents(_ value:Array<Duel.Pta.Api.PtaassistantEventPb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.events = value
        return self
      }
      @discardableResult
      public func clearEvents() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.events.removeAll(keepingCapacity: false)
        return self
      }
      public var nodes:Array<Duel.Pta.Api.PtaassistantNodePb> {
           get {
               return builderResult.nodes
           }
           set (value) {
               builderResult.nodes = value
           }
      }
      @discardableResult
      public func setNodes(_ value:Array<Duel.Pta.Api.PtaassistantNodePb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.nodes = value
        return self
      }
      @discardableResult
      public func clearNodes() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.nodes.removeAll(keepingCapacity: false)
        return self
      }
      public var paths:Array<Duel.Pta.Api.PtaassistantPathPb> {
           get {
               return builderResult.paths
           }
           set (value) {
               builderResult.paths = value
           }
      }
      @discardableResult
      public func setPaths(_ value:Array<Duel.Pta.Api.PtaassistantPathPb>) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.paths = value
        return self
      }
      @discardableResult
      public func clearPaths() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult.paths.removeAll(keepingCapacity: false)
        return self
      }
      public var hasStartNodeId:Bool {
           get {
                return builderResult.hasStartNodeId
           }
      }
      public var startNodeId:Int32 {
           get {
                return builderResult.startNodeId
           }
           set (value) {
               builderResult.hasStartNodeId = true
               builderResult.startNodeId = value
           }
      }
      @discardableResult
      public func setStartNodeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.startNodeId = value
        return self
      }
      @discardableResult
      public func clearStartNodeId() -> Duel.Pta.Api.PtaassistantResponsePb.Builder{
           builderResult.hasStartNodeId = false
           builderResult.startNodeId = Int32(0)
           return self
      }
      public var hasEndNodeId:Bool {
           get {
                return builderResult.hasEndNodeId
           }
      }
      public var endNodeId:Int32 {
           get {
                return builderResult.endNodeId
           }
           set (value) {
               builderResult.hasEndNodeId = true
               builderResult.endNodeId = value
           }
      }
      @discardableResult
      public func setEndNodeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        self.endNodeId = value
        return self
      }
      @discardableResult
      public func clearEndNodeId() -> Duel.Pta.Api.PtaassistantResponsePb.Builder{
           builderResult.hasEndNodeId = false
           builderResult.endNodeId = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantResponsePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        return try Duel.Pta.Api.PtaassistantResponsePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantResponsePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantResponsePb {
        let returnMe:Duel.Pta.Api.PtaassistantResponsePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantResponsePb) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        if other == Duel.Pta.Api.PtaassistantResponsePb() {
         return self
        }
        if other.hasRequestId {
             requestId = other.requestId
        }
        if other.hasRequestTime {
             requestTime = other.requestTime
        }
        if other.hasReportType {
             reportType = other.reportType
        }
        if !other.segments.isEmpty  {
           builderResult.segments += other.segments
        }
        if !other.edges.isEmpty  {
           builderResult.edges += other.edges
        }
        if !other.losEvents.isEmpty  {
           builderResult.losEvents += other.losEvents
        }
        if !other.events.isEmpty  {
           builderResult.events += other.events
        }
        if !other.nodes.isEmpty  {
           builderResult.nodes += other.nodes
        }
        if !other.paths.isEmpty  {
           builderResult.paths += other.paths
        }
        if other.hasStartNodeId {
             startNodeId = other.startNodeId
        }
        if other.hasEndNodeId {
             endNodeId = other.endNodeId
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            requestId = try codedInputStream.readInt32()

          case 16:
            requestTime = try codedInputStream.readInt64()

          case 24:
            reportType = try codedInputStream.readInt32()

          case 34:
            let subBuilder = Duel.Pta.Api.PtaassistantSegmentPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            segments.append(subBuilder.buildPartial())

          case 42:
            let subBuilder = Duel.Pta.Api.PtaassistantEdgePb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            edges.append(subBuilder.buildPartial())

          case 50:
            let subBuilder = Duel.Pta.Api.PtaassistantLosEventPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            losEvents.append(subBuilder.buildPartial())

          case 58:
            let subBuilder = Duel.Pta.Api.PtaassistantEventPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            events.append(subBuilder.buildPartial())

          case 66:
            let subBuilder = Duel.Pta.Api.PtaassistantNodePb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            nodes.append(subBuilder.buildPartial())

          case 74:
            let subBuilder = Duel.Pta.Api.PtaassistantPathPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            paths.append(subBuilder.buildPartial())

          case 80:
            startNodeId = try codedInputStream.readInt32()

          case 88:
            endNodeId = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantResponsePb.Builder()
        if let jsonValueRequestId = jsonMap["requestId"] as? Int {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)
        } else if let jsonValueRequestId = jsonMap["requestId"] as? String {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)!
        }
        if let jsonValueRequestTime = jsonMap["requestTime"] as? String {
          resultDecodedBuilder.requestTime = Int64(jsonValueRequestTime)!
        } else if let jsonValueRequestTime = jsonMap["requestTime"] as? Int {
          resultDecodedBuilder.requestTime = Int64(jsonValueRequestTime)
        }
        if let jsonValueReportType = jsonMap["reportType"] as? Int {
          resultDecodedBuilder.reportType = Int32(jsonValueReportType)
        } else if let jsonValueReportType = jsonMap["reportType"] as? String {
          resultDecodedBuilder.reportType = Int32(jsonValueReportType)!
        }
        if let jsonValueSegments = jsonMap["segments"] as? Array<Dictionary<String,Any>> {
          var jsonArraySegments:Array<Duel.Pta.Api.PtaassistantSegmentPb> = []
          for oneValueSegments in jsonValueSegments {
            let messageFromStringSegments = try Duel.Pta.Api.PtaassistantSegmentPb.Builder.decodeToBuilder(jsonMap:oneValueSegments).build()

            jsonArraySegments.append(messageFromStringSegments)
          }
          resultDecodedBuilder.segments = jsonArraySegments
        }
        if let jsonValueEdges = jsonMap["edges"] as? Array<Dictionary<String,Any>> {
          var jsonArrayEdges:Array<Duel.Pta.Api.PtaassistantEdgePb> = []
          for oneValueEdges in jsonValueEdges {
            let messageFromStringEdges = try Duel.Pta.Api.PtaassistantEdgePb.Builder.decodeToBuilder(jsonMap:oneValueEdges).build()

            jsonArrayEdges.append(messageFromStringEdges)
          }
          resultDecodedBuilder.edges = jsonArrayEdges
        }
        if let jsonValueLosEvents = jsonMap["losEvents"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLosEvents:Array<Duel.Pta.Api.PtaassistantLosEventPb> = []
          for oneValueLosEvents in jsonValueLosEvents {
            let messageFromStringLosEvents = try Duel.Pta.Api.PtaassistantLosEventPb.Builder.decodeToBuilder(jsonMap:oneValueLosEvents).build()

            jsonArrayLosEvents.append(messageFromStringLosEvents)
          }
          resultDecodedBuilder.losEvents = jsonArrayLosEvents
        }
        if let jsonValueEvents = jsonMap["events"] as? Array<Dictionary<String,Any>> {
          var jsonArrayEvents:Array<Duel.Pta.Api.PtaassistantEventPb> = []
          for oneValueEvents in jsonValueEvents {
            let messageFromStringEvents = try Duel.Pta.Api.PtaassistantEventPb.Builder.decodeToBuilder(jsonMap:oneValueEvents).build()

            jsonArrayEvents.append(messageFromStringEvents)
          }
          resultDecodedBuilder.events = jsonArrayEvents
        }
        if let jsonValueNodes = jsonMap["nodes"] as? Array<Dictionary<String,Any>> {
          var jsonArrayNodes:Array<Duel.Pta.Api.PtaassistantNodePb> = []
          for oneValueNodes in jsonValueNodes {
            let messageFromStringNodes = try Duel.Pta.Api.PtaassistantNodePb.Builder.decodeToBuilder(jsonMap:oneValueNodes).build()

            jsonArrayNodes.append(messageFromStringNodes)
          }
          resultDecodedBuilder.nodes = jsonArrayNodes
        }
        if let jsonValuePaths = jsonMap["paths"] as? Array<Dictionary<String,Any>> {
          var jsonArrayPaths:Array<Duel.Pta.Api.PtaassistantPathPb> = []
          for oneValuePaths in jsonValuePaths {
            let messageFromStringPaths = try Duel.Pta.Api.PtaassistantPathPb.Builder.decodeToBuilder(jsonMap:oneValuePaths).build()

            jsonArrayPaths.append(messageFromStringPaths)
          }
          resultDecodedBuilder.paths = jsonArrayPaths
        }
        if let jsonValueStartNodeId = jsonMap["startNodeId"] as? Int {
          resultDecodedBuilder.startNodeId = Int32(jsonValueStartNodeId)
        } else if let jsonValueStartNodeId = jsonMap["startNodeId"] as? String {
          resultDecodedBuilder.startNodeId = Int32(jsonValueStartNodeId)!
        }
        if let jsonValueEndNodeId = jsonMap["endNodeId"] as? Int {
          resultDecodedBuilder.endNodeId = Int32(jsonValueEndNodeId)
        } else if let jsonValueEndNodeId = jsonMap["endNodeId"] as? String {
          resultDecodedBuilder.endNodeId = Int32(jsonValueEndNodeId)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantResponsePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantSegmentPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantSegmentPb, rhs: Duel.Pta.Api.PtaassistantSegmentPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSegmentId == rhs.hasSegmentId) && (!lhs.hasSegmentId || lhs.segmentId == rhs.segmentId)
      fieldCheck = fieldCheck && (lhs.edgeIds == rhs.edgeIds)
      fieldCheck = fieldCheck && (lhs.hasMainAddress == rhs.hasMainAddress) && (!lhs.hasMainAddress || lhs.mainAddress == rhs.mainAddress)
      fieldCheck = fieldCheck && (lhs.hasLength == rhs.hasLength) && (!lhs.hasLength || lhs.length == rhs.length)
      fieldCheck = fieldCheck && (lhs.hasTravelTime == rhs.hasTravelTime) && (!lhs.hasTravelTime || lhs.travelTime == rhs.travelTime)
      fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
      fieldCheck = fieldCheck && (lhs.hasArrivalTime == rhs.hasArrivalTime) && (!lhs.hasArrivalTime || lhs.arrivalTime == rhs.arrivalTime)
      fieldCheck = fieldCheck && (lhs.hasInNodeId == rhs.hasInNodeId) && (!lhs.hasInNodeId || lhs.inNodeId == rhs.inNodeId)
      fieldCheck = fieldCheck && (lhs.hasOutNodeId == rhs.hasOutNodeId) && (!lhs.hasOutNodeId || lhs.outNodeId == rhs.outNodeId)
      fieldCheck = fieldCheck && (lhs.hasRemainingM == rhs.hasRemainingM) && (!lhs.hasRemainingM || lhs.remainingM == rhs.remainingM)
      fieldCheck = fieldCheck && (lhs.lod == rhs.lod)
      fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
      fieldCheck = fieldCheck && (lhs.trafficEventIds == rhs.trafficEventIds)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var segmentId:Int32 = Int32(0)
    public fileprivate(set) var hasSegmentId:Bool = false

    //lista id degli edge che compongono il segmento
    public fileprivate(set) var edgeIds:Array<Int32> = Array<Int32>()
    public fileprivate(set) var mainAddress:String = ""
    public fileprivate(set) var hasMainAddress:Bool = false

    //lunghezza del segmento
    public fileprivate(set) var length:Float = Float(0)
    public fileprivate(set) var hasLength:Bool = false

    //tempo di percorrenza del segmento
    public fileprivate(set) var travelTime:Int32 = Int32(0)
    public fileprivate(set) var hasTravelTime:Bool = false

    public fileprivate(set) var description_:String = ""
    public fileprivate(set) var hasDescription:Bool = false

    //estimated arrival time fastest path
    public fileprivate(set) var arrivalTime:Int64 = Int64(0)
    public fileprivate(set) var hasArrivalTime:Bool = false

    public fileprivate(set) var inNodeId:Int32 = Int32(0)
    public fileprivate(set) var hasInNodeId:Bool = false

    public fileprivate(set) var outNodeId:Int32 = Int32(0)
    public fileprivate(set) var hasOutNodeId:Bool = false

    // distanza minore su shortestpath dal target
    public fileprivate(set) var remainingM:Float = Float(0)
    public fileprivate(set) var hasRemainingM:Bool = false

    public fileprivate(set) var lod:Array<Duel.Pta.Api.PtaassistantLodPb>  = Array<Duel.Pta.Api.PtaassistantLodPb>()
    public fileprivate(set) var type:Duel.Pta.Api.PtapathType = Duel.Pta.Api.PtapathType.typical
    public fileprivate(set) var hasType:Bool = false
    //lista id eventi di redazione
    public fileprivate(set) var trafficEventIds:Array<String> = Array<String>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSegmentId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:segmentId)
      }
      if !edgeIds.isEmpty {
        for oneValueedgeIds in edgeIds {
          try codedOutputStream.writeInt32(fieldNumber: 2, value:oneValueedgeIds)
        }
      }
      if hasMainAddress {
        try codedOutputStream.writeString(fieldNumber: 3, value:mainAddress)
      }
      if hasLength {
        try codedOutputStream.writeFloat(fieldNumber: 4, value:length)
      }
      if hasTravelTime {
        try codedOutputStream.writeInt32(fieldNumber: 5, value:travelTime)
      }
      if hasDescription {
        try codedOutputStream.writeString(fieldNumber: 6, value:description_)
      }
      if hasArrivalTime {
        try codedOutputStream.writeInt64(fieldNumber: 7, value:arrivalTime)
      }
      if hasInNodeId {
        try codedOutputStream.writeInt32(fieldNumber: 8, value:inNodeId)
      }
      if hasOutNodeId {
        try codedOutputStream.writeInt32(fieldNumber: 9, value:outNodeId)
      }
      if hasRemainingM {
        try codedOutputStream.writeFloat(fieldNumber: 10, value:remainingM)
      }
      for oneElementLod in lod {
          try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementLod)
      }
      if hasType {
        try codedOutputStream.writeEnum(fieldNumber: 12, value:type.rawValue)
      }
      if !trafficEventIds.isEmpty {
        for oneValuetrafficEventIds in trafficEventIds {
          try codedOutputStream.writeString(fieldNumber: 13, value:oneValuetrafficEventIds)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSegmentId {
        serialize_size += segmentId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizeEdgeIds:Int32 = 0
      for oneValueedgeIds in edgeIds {
          dataSizeEdgeIds += oneValueedgeIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeEdgeIds
      serialize_size += 1 * Int32(edgeIds.count)
      if hasMainAddress {
        serialize_size += mainAddress.computeStringSize(fieldNumber: 3)
      }
      if hasLength {
        serialize_size += length.computeFloatSize(fieldNumber: 4)
      }
      if hasTravelTime {
        serialize_size += travelTime.computeInt32Size(fieldNumber: 5)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(fieldNumber: 6)
      }
      if hasArrivalTime {
        serialize_size += arrivalTime.computeInt64Size(fieldNumber: 7)
      }
      if hasInNodeId {
        serialize_size += inNodeId.computeInt32Size(fieldNumber: 8)
      }
      if hasOutNodeId {
        serialize_size += outNodeId.computeInt32Size(fieldNumber: 9)
      }
      if hasRemainingM {
        serialize_size += remainingM.computeFloatSize(fieldNumber: 10)
      }
      for oneElementLod in lod {
          serialize_size += oneElementLod.computeMessageSize(fieldNumber: 11)
      }
      if (hasType) {
        serialize_size += type.rawValue.computeEnumSize(fieldNumber: 12)
      }
      var dataSizeTrafficEventIds:Int32 = 0
      for oneValuetrafficEventIds in trafficEventIds {
          dataSizeTrafficEventIds += oneValuetrafficEventIds.computeStringSizeNoTag()
      }
      serialize_size += dataSizeTrafficEventIds
      serialize_size += 1 * Int32(trafficEventIds.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
      return Duel.Pta.Api.PtaassistantSegmentPb.classBuilder() as! Duel.Pta.Api.PtaassistantSegmentPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantSegmentPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantSegmentPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantSegmentPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
      return try Duel.Pta.Api.PtaassistantSegmentPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantSegmentPb) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
      return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSegmentId {
        jsonMap["segmentId"] = Int(segmentId)
      }
      if !edgeIds.isEmpty {
        var jsonArrayEdgeIds:Array<Int> = []
          for oneValueEdgeIds in edgeIds {
            jsonArrayEdgeIds.append(Int(oneValueEdgeIds))
          }
        jsonMap["edgeIds"] = jsonArrayEdgeIds
      }
      if hasMainAddress {
        jsonMap["mainAddress"] = mainAddress
      }
      if hasLength {
        jsonMap["length"] = Float(length)
      }
      if hasTravelTime {
        jsonMap["travelTime"] = Int(travelTime)
      }
      if hasDescription {
        jsonMap["description"] = description_
      }
      if hasArrivalTime {
        jsonMap["arrivalTime"] = "\(arrivalTime)"
      }
      if hasInNodeId {
        jsonMap["inNodeId"] = Int(inNodeId)
      }
      if hasOutNodeId {
        jsonMap["outNodeId"] = Int(outNodeId)
      }
      if hasRemainingM {
        jsonMap["remainingM"] = Float(remainingM)
      }
      if !lod.isEmpty {
        var jsonArrayLod:Array<Dictionary<String,Any>> = []
          for oneValueLod in lod {
            let ecodedMessageLod = try oneValueLod.encode()
            jsonArrayLod.append(ecodedMessageLod)
          }
        jsonMap["lod"] = jsonArrayLod
      }
      if hasType {
        jsonMap["type"] = type.toString()
      }
      if !trafficEventIds.isEmpty {
        var jsonArrayTrafficEventIds:Array<String> = []
          for oneValueTrafficEventIds in trafficEventIds {
            jsonArrayTrafficEventIds.append(oneValueTrafficEventIds)
          }
        jsonMap["trafficEventIds"] = jsonArrayTrafficEventIds
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
      return try Duel.Pta.Api.PtaassistantSegmentPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
      return try Duel.Pta.Api.PtaassistantSegmentPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSegmentId {
        output += "\(indent) segmentId: \(segmentId) \n"
      }
      var edgeIdsElementIndex:Int = 0
      for oneValueEdgeIds in edgeIds  {
          output += "\(indent) edgeIds[\(edgeIdsElementIndex)]: \(oneValueEdgeIds)\n"
          edgeIdsElementIndex += 1
      }
      if hasMainAddress {
        output += "\(indent) mainAddress: \(mainAddress) \n"
      }
      if hasLength {
        output += "\(indent) length: \(length) \n"
      }
      if hasTravelTime {
        output += "\(indent) travelTime: \(travelTime) \n"
      }
      if hasDescription {
        output += "\(indent) description: \(description_) \n"
      }
      if hasArrivalTime {
        output += "\(indent) arrivalTime: \(arrivalTime) \n"
      }
      if hasInNodeId {
        output += "\(indent) inNodeId: \(inNodeId) \n"
      }
      if hasOutNodeId {
        output += "\(indent) outNodeId: \(outNodeId) \n"
      }
      if hasRemainingM {
        output += "\(indent) remainingM: \(remainingM) \n"
      }
      var lodElementIndex:Int = 0
      for oneElementLod in lod {
          output += "\(indent) lod[\(lodElementIndex)] {\n"
          output += try oneElementLod.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          lodElementIndex += 1
      }
      if (hasType) {
        output += "\(indent) type: \(type.description)\n"
      }
      var trafficEventIdsElementIndex:Int = 0
      for oneValueTrafficEventIds in trafficEventIds  {
          output += "\(indent) trafficEventIds[\(trafficEventIdsElementIndex)]: \(oneValueTrafficEventIds)\n"
          trafficEventIdsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSegmentId {
               hashCode = (hashCode &* 31) &+ segmentId.hashValue
            }
            for oneValueEdgeIds in edgeIds {
                hashCode = (hashCode &* 31) &+ oneValueEdgeIds.hashValue
            }
            if hasMainAddress {
               hashCode = (hashCode &* 31) &+ mainAddress.hashValue
            }
            if hasLength {
               hashCode = (hashCode &* 31) &+ length.hashValue
            }
            if hasTravelTime {
               hashCode = (hashCode &* 31) &+ travelTime.hashValue
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            if hasArrivalTime {
               hashCode = (hashCode &* 31) &+ arrivalTime.hashValue
            }
            if hasInNodeId {
               hashCode = (hashCode &* 31) &+ inNodeId.hashValue
            }
            if hasOutNodeId {
               hashCode = (hashCode &* 31) &+ outNodeId.hashValue
            }
            if hasRemainingM {
               hashCode = (hashCode &* 31) &+ remainingM.hashValue
            }
            for oneElementLod in lod {
                hashCode = (hashCode &* 31) &+ oneElementLod.hashValue
            }
            if hasType {
               hashCode = (hashCode &* 31) &+ Int(type.rawValue)
            }
            for oneValueTrafficEventIds in trafficEventIds {
                hashCode = (hashCode &* 31) &+ oneValueTrafficEventIds.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantSegmentPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantSegmentPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantSegmentPb = Duel.Pta.Api.PtaassistantSegmentPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantSegmentPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSegmentId:Bool {
           get {
                return builderResult.hasSegmentId
           }
      }
      public var segmentId:Int32 {
           get {
                return builderResult.segmentId
           }
           set (value) {
               builderResult.hasSegmentId = true
               builderResult.segmentId = value
           }
      }
      @discardableResult
      public func setSegmentId(_ value:Int32) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.segmentId = value
        return self
      }
      @discardableResult
      public func clearSegmentId() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasSegmentId = false
           builderResult.segmentId = Int32(0)
           return self
      }
      public var edgeIds:Array<Int32> {
           get {
               return builderResult.edgeIds
           }
           set (array) {
               builderResult.edgeIds = array
           }
      }
      @discardableResult
      public func setEdgeIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.edgeIds = value
        return self
      }
      @discardableResult
      public func clearEdgeIds() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
         builderResult.edgeIds.removeAll(keepingCapacity: false)
         return self
      }
      public var hasMainAddress:Bool {
           get {
                return builderResult.hasMainAddress
           }
      }
      public var mainAddress:String {
           get {
                return builderResult.mainAddress
           }
           set (value) {
               builderResult.hasMainAddress = true
               builderResult.mainAddress = value
           }
      }
      @discardableResult
      public func setMainAddress(_ value:String) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.mainAddress = value
        return self
      }
      @discardableResult
      public func clearMainAddress() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasMainAddress = false
           builderResult.mainAddress = ""
           return self
      }
      public var hasLength:Bool {
           get {
                return builderResult.hasLength
           }
      }
      public var length:Float {
           get {
                return builderResult.length
           }
           set (value) {
               builderResult.hasLength = true
               builderResult.length = value
           }
      }
      @discardableResult
      public func setLength(_ value:Float) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.length = value
        return self
      }
      @discardableResult
      public func clearLength() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasLength = false
           builderResult.length = Float(0)
           return self
      }
      public var hasTravelTime:Bool {
           get {
                return builderResult.hasTravelTime
           }
      }
      public var travelTime:Int32 {
           get {
                return builderResult.travelTime
           }
           set (value) {
               builderResult.hasTravelTime = true
               builderResult.travelTime = value
           }
      }
      @discardableResult
      public func setTravelTime(_ value:Int32) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.travelTime = value
        return self
      }
      @discardableResult
      public func clearTravelTime() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasTravelTime = false
           builderResult.travelTime = Int32(0)
           return self
      }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      @discardableResult
      public func setDescription(_ value:String) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.description_ = value
        return self
      }
      @discardableResult
      public func clearDescription() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      public var hasArrivalTime:Bool {
           get {
                return builderResult.hasArrivalTime
           }
      }
      public var arrivalTime:Int64 {
           get {
                return builderResult.arrivalTime
           }
           set (value) {
               builderResult.hasArrivalTime = true
               builderResult.arrivalTime = value
           }
      }
      @discardableResult
      public func setArrivalTime(_ value:Int64) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.arrivalTime = value
        return self
      }
      @discardableResult
      public func clearArrivalTime() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasArrivalTime = false
           builderResult.arrivalTime = Int64(0)
           return self
      }
      public var hasInNodeId:Bool {
           get {
                return builderResult.hasInNodeId
           }
      }
      public var inNodeId:Int32 {
           get {
                return builderResult.inNodeId
           }
           set (value) {
               builderResult.hasInNodeId = true
               builderResult.inNodeId = value
           }
      }
      @discardableResult
      public func setInNodeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.inNodeId = value
        return self
      }
      @discardableResult
      public func clearInNodeId() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasInNodeId = false
           builderResult.inNodeId = Int32(0)
           return self
      }
      public var hasOutNodeId:Bool {
           get {
                return builderResult.hasOutNodeId
           }
      }
      public var outNodeId:Int32 {
           get {
                return builderResult.outNodeId
           }
           set (value) {
               builderResult.hasOutNodeId = true
               builderResult.outNodeId = value
           }
      }
      @discardableResult
      public func setOutNodeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.outNodeId = value
        return self
      }
      @discardableResult
      public func clearOutNodeId() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasOutNodeId = false
           builderResult.outNodeId = Int32(0)
           return self
      }
      public var hasRemainingM:Bool {
           get {
                return builderResult.hasRemainingM
           }
      }
      public var remainingM:Float {
           get {
                return builderResult.remainingM
           }
           set (value) {
               builderResult.hasRemainingM = true
               builderResult.remainingM = value
           }
      }
      @discardableResult
      public func setRemainingM(_ value:Float) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.remainingM = value
        return self
      }
      @discardableResult
      public func clearRemainingM() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder{
           builderResult.hasRemainingM = false
           builderResult.remainingM = Float(0)
           return self
      }
      public var lod:Array<Duel.Pta.Api.PtaassistantLodPb> {
           get {
               return builderResult.lod
           }
           set (value) {
               builderResult.lod = value
           }
      }
      @discardableResult
      public func setLod(_ value:Array<Duel.Pta.Api.PtaassistantLodPb>) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.lod = value
        return self
      }
      @discardableResult
      public func clearLod() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        builderResult.lod.removeAll(keepingCapacity: false)
        return self
      }
        public var hasType:Bool{
            get {
                return builderResult.hasType
            }
        }
        public var type:Duel.Pta.Api.PtapathType {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
      @discardableResult
        public func setType(_ value:Duel.Pta.Api.PtapathType) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
          self.type = value
          return self
        }
      @discardableResult
        public func clearType() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
           builderResult.hasType = false
           builderResult.type = .typical
           return self
        }
      public var trafficEventIds:Array<String> {
           get {
               return builderResult.trafficEventIds
           }
           set (array) {
               builderResult.trafficEventIds = array
           }
      }
      @discardableResult
      public func setTrafficEventIds(_ value:Array<String>) -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        self.trafficEventIds = value
        return self
      }
      @discardableResult
      public func clearTrafficEventIds() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
         builderResult.trafficEventIds.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantSegmentPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        return try Duel.Pta.Api.PtaassistantSegmentPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantSegmentPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantSegmentPb {
        let returnMe:Duel.Pta.Api.PtaassistantSegmentPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantSegmentPb) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        if other == Duel.Pta.Api.PtaassistantSegmentPb() {
         return self
        }
        if other.hasSegmentId {
             segmentId = other.segmentId
        }
        if !other.edgeIds.isEmpty {
            builderResult.edgeIds += other.edgeIds
        }
        if other.hasMainAddress {
             mainAddress = other.mainAddress
        }
        if other.hasLength {
             length = other.length
        }
        if other.hasTravelTime {
             travelTime = other.travelTime
        }
        if other.hasDescription {
             description_ = other.description_
        }
        if other.hasArrivalTime {
             arrivalTime = other.arrivalTime
        }
        if other.hasInNodeId {
             inNodeId = other.inNodeId
        }
        if other.hasOutNodeId {
             outNodeId = other.outNodeId
        }
        if other.hasRemainingM {
             remainingM = other.remainingM
        }
        if !other.lod.isEmpty  {
           builderResult.lod += other.lod
        }
        if other.hasType {
             type = other.type
        }
        if !other.trafficEventIds.isEmpty {
            builderResult.trafficEventIds += other.trafficEventIds
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            segmentId = try codedInputStream.readInt32()

          case 16:
            edgeIds += [try codedInputStream.readInt32()]

          case 26:
            mainAddress = try codedInputStream.readString()

          case 37:
            length = try codedInputStream.readFloat()

          case 40:
            travelTime = try codedInputStream.readInt32()

          case 50:
            description_ = try codedInputStream.readString()

          case 56:
            arrivalTime = try codedInputStream.readInt64()

          case 64:
            inNodeId = try codedInputStream.readInt32()

          case 72:
            outNodeId = try codedInputStream.readInt32()

          case 85:
            remainingM = try codedInputStream.readFloat()

          case 90:
            let subBuilder = Duel.Pta.Api.PtaassistantLodPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            lod.append(subBuilder.buildPartial())

          case 96:
            let valueInttype = try codedInputStream.readEnum()
            if let enumstype = Duel.Pta.Api.PtapathType(rawValue:valueInttype){
                 type = enumstype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 12, value:Int64(valueInttype))
            }

          case 106:
            trafficEventIds += [try codedInputStream.readString()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantSegmentPb.Builder()
        if let jsonValueSegmentId = jsonMap["segmentId"] as? Int {
          resultDecodedBuilder.segmentId = Int32(jsonValueSegmentId)
        } else if let jsonValueSegmentId = jsonMap["segmentId"] as? String {
          resultDecodedBuilder.segmentId = Int32(jsonValueSegmentId)!
        }
        if let jsonValueEdgeIds = jsonMap["edgeIds"] as? Array<Int> {
          var jsonArrayEdgeIds:Array<Int32> = []
          for oneValueEdgeIds in jsonValueEdgeIds {
            jsonArrayEdgeIds.append(Int32(oneValueEdgeIds))
          }
          resultDecodedBuilder.edgeIds = jsonArrayEdgeIds
        }
        if let jsonValueMainAddress = jsonMap["mainAddress"] as? String {
          resultDecodedBuilder.mainAddress = jsonValueMainAddress
        }
        if let jsonValueLength = jsonMap["length"] as? Float {
          resultDecodedBuilder.length = Float(jsonValueLength)
        } else if let jsonValueLength = jsonMap["length"] as? String {
          resultDecodedBuilder.length = Float(jsonValueLength)!
        }
        if let jsonValueTravelTime = jsonMap["travelTime"] as? Int {
          resultDecodedBuilder.travelTime = Int32(jsonValueTravelTime)
        } else if let jsonValueTravelTime = jsonMap["travelTime"] as? String {
          resultDecodedBuilder.travelTime = Int32(jsonValueTravelTime)!
        }
        if let jsonValueDescription = jsonMap["description"] as? String {
          resultDecodedBuilder.description_ = jsonValueDescription
        }
        if let jsonValueArrivalTime = jsonMap["arrivalTime"] as? String {
          resultDecodedBuilder.arrivalTime = Int64(jsonValueArrivalTime)!
        } else if let jsonValueArrivalTime = jsonMap["arrivalTime"] as? Int {
          resultDecodedBuilder.arrivalTime = Int64(jsonValueArrivalTime)
        }
        if let jsonValueInNodeId = jsonMap["inNodeId"] as? Int {
          resultDecodedBuilder.inNodeId = Int32(jsonValueInNodeId)
        } else if let jsonValueInNodeId = jsonMap["inNodeId"] as? String {
          resultDecodedBuilder.inNodeId = Int32(jsonValueInNodeId)!
        }
        if let jsonValueOutNodeId = jsonMap["outNodeId"] as? Int {
          resultDecodedBuilder.outNodeId = Int32(jsonValueOutNodeId)
        } else if let jsonValueOutNodeId = jsonMap["outNodeId"] as? String {
          resultDecodedBuilder.outNodeId = Int32(jsonValueOutNodeId)!
        }
        if let jsonValueRemainingM = jsonMap["remainingM"] as? Float {
          resultDecodedBuilder.remainingM = Float(jsonValueRemainingM)
        } else if let jsonValueRemainingM = jsonMap["remainingM"] as? String {
          resultDecodedBuilder.remainingM = Float(jsonValueRemainingM)!
        }
        if let jsonValueLod = jsonMap["lod"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLod:Array<Duel.Pta.Api.PtaassistantLodPb> = []
          for oneValueLod in jsonValueLod {
            let messageFromStringLod = try Duel.Pta.Api.PtaassistantLodPb.Builder.decodeToBuilder(jsonMap:oneValueLod).build()

            jsonArrayLod.append(messageFromStringLod)
          }
          resultDecodedBuilder.lod = jsonArrayLod
        }
        if let jsonValueType = jsonMap["type"] as? String {
          resultDecodedBuilder.type = try Duel.Pta.Api.PtapathType.fromString(str: jsonValueType)
        }
        if let jsonValueTrafficEventIds = jsonMap["trafficEventIds"] as? Array<String> {
          var jsonArrayTrafficEventIds:Array<String> = []
          for oneValueTrafficEventIds in jsonValueTrafficEventIds {
            jsonArrayTrafficEventIds.append(oneValueTrafficEventIds)
          }
          resultDecodedBuilder.trafficEventIds = jsonArrayTrafficEventIds
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantSegmentPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantSegmentPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantNodePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantNodePb, rhs: Duel.Pta.Api.PtaassistantNodePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
      fieldCheck = fieldCheck && (lhs.hasLon == rhs.hasLon) && (!lhs.hasLon || lhs.lon == rhs.lon)
      fieldCheck = fieldCheck && (lhs.hasLat == rhs.hasLat) && (!lhs.hasLat || lhs.lat == rhs.lat)
      fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
      fieldCheck = fieldCheck && (lhs.lodEvent == rhs.lodEvent)
      fieldCheck = fieldCheck && (lhs.nextSegmentIds == rhs.nextSegmentIds)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var nodeId:Int32 = Int32(0)
    public fileprivate(set) var hasNodeId:Bool = false

    public fileprivate(set) var lon:Float = Float(0)
    public fileprivate(set) var hasLon:Bool = false

    public fileprivate(set) var lat:Float = Float(0)
    public fileprivate(set) var hasLat:Bool = false

    public fileprivate(set) var type:Int32 = Int32(0)
    public fileprivate(set) var hasType:Bool = false

    public fileprivate(set) var lodEvent:Array<Duel.Pta.Api.PtaassistantLodPb>  = Array<Duel.Pta.Api.PtaassistantLodPb>()
    //lista id dei segmenti in uscita
    public fileprivate(set) var nextSegmentIds:Array<Int32> = Array<Int32>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasNodeId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:nodeId)
      }
      if hasLon {
        try codedOutputStream.writeFloat(fieldNumber: 2, value:lon)
      }
      if hasLat {
        try codedOutputStream.writeFloat(fieldNumber: 3, value:lat)
      }
      if hasType {
        try codedOutputStream.writeInt32(fieldNumber: 4, value:type)
      }
      for oneElementLodEvent in lodEvent {
          try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementLodEvent)
      }
      if !nextSegmentIds.isEmpty {
        for oneValuenextSegmentIds in nextSegmentIds {
          try codedOutputStream.writeInt32(fieldNumber: 6, value:oneValuenextSegmentIds)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasNodeId {
        serialize_size += nodeId.computeInt32Size(fieldNumber: 1)
      }
      if hasLon {
        serialize_size += lon.computeFloatSize(fieldNumber: 2)
      }
      if hasLat {
        serialize_size += lat.computeFloatSize(fieldNumber: 3)
      }
      if hasType {
        serialize_size += type.computeInt32Size(fieldNumber: 4)
      }
      for oneElementLodEvent in lodEvent {
          serialize_size += oneElementLodEvent.computeMessageSize(fieldNumber: 5)
      }
      var dataSizeNextSegmentIds:Int32 = 0
      for oneValuenextSegmentIds in nextSegmentIds {
          dataSizeNextSegmentIds += oneValuenextSegmentIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeNextSegmentIds
      serialize_size += 1 * Int32(nextSegmentIds.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantNodePb.Builder {
      return Duel.Pta.Api.PtaassistantNodePb.classBuilder() as! Duel.Pta.Api.PtaassistantNodePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantNodePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantNodePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantNodePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantNodePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
      return try Duel.Pta.Api.PtaassistantNodePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantNodePb) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
      return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasNodeId {
        jsonMap["nodeId"] = Int(nodeId)
      }
      if hasLon {
        jsonMap["lon"] = Float(lon)
      }
      if hasLat {
        jsonMap["lat"] = Float(lat)
      }
      if hasType {
        jsonMap["type"] = Int(type)
      }
      if !lodEvent.isEmpty {
        var jsonArrayLodEvent:Array<Dictionary<String,Any>> = []
          for oneValueLodEvent in lodEvent {
            let ecodedMessageLodEvent = try oneValueLodEvent.encode()
            jsonArrayLodEvent.append(ecodedMessageLodEvent)
          }
        jsonMap["lodEvent"] = jsonArrayLodEvent
      }
      if !nextSegmentIds.isEmpty {
        var jsonArrayNextSegmentIds:Array<Int> = []
          for oneValueNextSegmentIds in nextSegmentIds {
            jsonArrayNextSegmentIds.append(Int(oneValueNextSegmentIds))
          }
        jsonMap["nextSegmentIds"] = jsonArrayNextSegmentIds
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantNodePb {
      return try Duel.Pta.Api.PtaassistantNodePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantNodePb {
      return try Duel.Pta.Api.PtaassistantNodePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasNodeId {
        output += "\(indent) nodeId: \(nodeId) \n"
      }
      if hasLon {
        output += "\(indent) lon: \(lon) \n"
      }
      if hasLat {
        output += "\(indent) lat: \(lat) \n"
      }
      if hasType {
        output += "\(indent) type: \(type) \n"
      }
      var lodEventElementIndex:Int = 0
      for oneElementLodEvent in lodEvent {
          output += "\(indent) lodEvent[\(lodEventElementIndex)] {\n"
          output += try oneElementLodEvent.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          lodEventElementIndex += 1
      }
      var nextSegmentIdsElementIndex:Int = 0
      for oneValueNextSegmentIds in nextSegmentIds  {
          output += "\(indent) nextSegmentIds[\(nextSegmentIdsElementIndex)]: \(oneValueNextSegmentIds)\n"
          nextSegmentIdsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasNodeId {
               hashCode = (hashCode &* 31) &+ nodeId.hashValue
            }
            if hasLon {
               hashCode = (hashCode &* 31) &+ lon.hashValue
            }
            if hasLat {
               hashCode = (hashCode &* 31) &+ lat.hashValue
            }
            if hasType {
               hashCode = (hashCode &* 31) &+ type.hashValue
            }
            for oneElementLodEvent in lodEvent {
                hashCode = (hashCode &* 31) &+ oneElementLodEvent.hashValue
            }
            for oneValueNextSegmentIds in nextSegmentIds {
                hashCode = (hashCode &* 31) &+ oneValueNextSegmentIds.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantNodePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantNodePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantNodePb = Duel.Pta.Api.PtaassistantNodePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantNodePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasNodeId:Bool {
           get {
                return builderResult.hasNodeId
           }
      }
      public var nodeId:Int32 {
           get {
                return builderResult.nodeId
           }
           set (value) {
               builderResult.hasNodeId = true
               builderResult.nodeId = value
           }
      }
      @discardableResult
      public func setNodeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.nodeId = value
        return self
      }
      @discardableResult
      public func clearNodeId() -> Duel.Pta.Api.PtaassistantNodePb.Builder{
           builderResult.hasNodeId = false
           builderResult.nodeId = Int32(0)
           return self
      }
      public var hasLon:Bool {
           get {
                return builderResult.hasLon
           }
      }
      public var lon:Float {
           get {
                return builderResult.lon
           }
           set (value) {
               builderResult.hasLon = true
               builderResult.lon = value
           }
      }
      @discardableResult
      public func setLon(_ value:Float) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.lon = value
        return self
      }
      @discardableResult
      public func clearLon() -> Duel.Pta.Api.PtaassistantNodePb.Builder{
           builderResult.hasLon = false
           builderResult.lon = Float(0)
           return self
      }
      public var hasLat:Bool {
           get {
                return builderResult.hasLat
           }
      }
      public var lat:Float {
           get {
                return builderResult.lat
           }
           set (value) {
               builderResult.hasLat = true
               builderResult.lat = value
           }
      }
      @discardableResult
      public func setLat(_ value:Float) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.lat = value
        return self
      }
      @discardableResult
      public func clearLat() -> Duel.Pta.Api.PtaassistantNodePb.Builder{
           builderResult.hasLat = false
           builderResult.lat = Float(0)
           return self
      }
      public var hasType:Bool {
           get {
                return builderResult.hasType
           }
      }
      public var type:Int32 {
           get {
                return builderResult.type
           }
           set (value) {
               builderResult.hasType = true
               builderResult.type = value
           }
      }
      @discardableResult
      public func setType(_ value:Int32) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.type = value
        return self
      }
      @discardableResult
      public func clearType() -> Duel.Pta.Api.PtaassistantNodePb.Builder{
           builderResult.hasType = false
           builderResult.type = Int32(0)
           return self
      }
      public var lodEvent:Array<Duel.Pta.Api.PtaassistantLodPb> {
           get {
               return builderResult.lodEvent
           }
           set (value) {
               builderResult.lodEvent = value
           }
      }
      @discardableResult
      public func setLodEvent(_ value:Array<Duel.Pta.Api.PtaassistantLodPb>) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.lodEvent = value
        return self
      }
      @discardableResult
      public func clearLodEvent() -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        builderResult.lodEvent.removeAll(keepingCapacity: false)
        return self
      }
      public var nextSegmentIds:Array<Int32> {
           get {
               return builderResult.nextSegmentIds
           }
           set (array) {
               builderResult.nextSegmentIds = array
           }
      }
      @discardableResult
      public func setNextSegmentIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        self.nextSegmentIds = value
        return self
      }
      @discardableResult
      public func clearNextSegmentIds() -> Duel.Pta.Api.PtaassistantNodePb.Builder {
         builderResult.nextSegmentIds.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantNodePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        return try Duel.Pta.Api.PtaassistantNodePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantNodePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantNodePb {
        let returnMe:Duel.Pta.Api.PtaassistantNodePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantNodePb) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        if other == Duel.Pta.Api.PtaassistantNodePb() {
         return self
        }
        if other.hasNodeId {
             nodeId = other.nodeId
        }
        if other.hasLon {
             lon = other.lon
        }
        if other.hasLat {
             lat = other.lat
        }
        if other.hasType {
             type = other.type
        }
        if !other.lodEvent.isEmpty  {
           builderResult.lodEvent += other.lodEvent
        }
        if !other.nextSegmentIds.isEmpty {
            builderResult.nextSegmentIds += other.nextSegmentIds
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            nodeId = try codedInputStream.readInt32()

          case 21:
            lon = try codedInputStream.readFloat()

          case 29:
            lat = try codedInputStream.readFloat()

          case 32:
            type = try codedInputStream.readInt32()

          case 42:
            let subBuilder = Duel.Pta.Api.PtaassistantLodPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            lodEvent.append(subBuilder.buildPartial())

          case 48:
            nextSegmentIds += [try codedInputStream.readInt32()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantNodePb.Builder()
        if let jsonValueNodeId = jsonMap["nodeId"] as? Int {
          resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)
        } else if let jsonValueNodeId = jsonMap["nodeId"] as? String {
          resultDecodedBuilder.nodeId = Int32(jsonValueNodeId)!
        }
        if let jsonValueLon = jsonMap["lon"] as? Float {
          resultDecodedBuilder.lon = Float(jsonValueLon)
        } else if let jsonValueLon = jsonMap["lon"] as? String {
          resultDecodedBuilder.lon = Float(jsonValueLon)!
        }
        if let jsonValueLat = jsonMap["lat"] as? Float {
          resultDecodedBuilder.lat = Float(jsonValueLat)
        } else if let jsonValueLat = jsonMap["lat"] as? String {
          resultDecodedBuilder.lat = Float(jsonValueLat)!
        }
        if let jsonValueType = jsonMap["type"] as? Int {
          resultDecodedBuilder.type = Int32(jsonValueType)
        } else if let jsonValueType = jsonMap["type"] as? String {
          resultDecodedBuilder.type = Int32(jsonValueType)!
        }
        if let jsonValueLodEvent = jsonMap["lodEvent"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLodEvent:Array<Duel.Pta.Api.PtaassistantLodPb> = []
          for oneValueLodEvent in jsonValueLodEvent {
            let messageFromStringLodEvent = try Duel.Pta.Api.PtaassistantLodPb.Builder.decodeToBuilder(jsonMap:oneValueLodEvent).build()

            jsonArrayLodEvent.append(messageFromStringLodEvent)
          }
          resultDecodedBuilder.lodEvent = jsonArrayLodEvent
        }
        if let jsonValueNextSegmentIds = jsonMap["nextSegmentIds"] as? Array<Int> {
          var jsonArrayNextSegmentIds:Array<Int32> = []
          for oneValueNextSegmentIds in jsonValueNextSegmentIds {
            jsonArrayNextSegmentIds.append(Int32(oneValueNextSegmentIds))
          }
          resultDecodedBuilder.nextSegmentIds = jsonArrayNextSegmentIds
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantNodePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantNodePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantEdgePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantEdgePb, rhs: Duel.Pta.Api.PtaassistantEdgePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasEdgeId == rhs.hasEdgeId) && (!lhs.hasEdgeId || lhs.edgeId == rhs.edgeId)
      fieldCheck = fieldCheck && (lhs.geometryPoint == rhs.geometryPoint)
      fieldCheck = fieldCheck && (lhs.hasTrLevel == rhs.hasTrLevel) && (!lhs.hasTrLevel || lhs.trLevel == rhs.trLevel)
      fieldCheck = fieldCheck && (lhs.hasLength == rhs.hasLength) && (!lhs.hasLength || lhs.length == rhs.length)
      fieldCheck = fieldCheck && (lhs.hasSpeed == rhs.hasSpeed) && (!lhs.hasSpeed || lhs.speed == rhs.speed)
      fieldCheck = fieldCheck && (lhs.hasFfs == rhs.hasFfs) && (!lhs.hasFfs || lhs.ffs == rhs.ffs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var edgeId:Int32 = Int32(0)
    public fileprivate(set) var hasEdgeId:Bool = false

    // geometria-lista di longitudini e latitudini
    public fileprivate(set) var geometryPoint:Array<Float> = Array<Float>()
    private var geometryPointMemoizedSerializedSize:Int32 = -1
    //livello traffico [-1...3] ricalcolato sulle steproute
    public fileprivate(set) var trLevel:Int32 = Int32(0)
    public fileprivate(set) var hasTrLevel:Bool = false

    //lunghezza dell'arco
    public fileprivate(set) var length:Float = Float(0)
    public fileprivate(set) var hasLength:Bool = false

    //velocità effettiva sull'arco
    public fileprivate(set) var speed:Float = Float(0)
    public fileprivate(set) var hasSpeed:Bool = false

    //free flow speed
    public fileprivate(set) var ffs:Float = Float(0)
    public fileprivate(set) var hasFfs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasEdgeId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:edgeId)
      }
      if !geometryPoint.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 18)
        try codedOutputStream.writeRawVarint32(value: geometryPointMemoizedSerializedSize)
        for oneValuegeometryPoint in geometryPoint {
          try codedOutputStream.writeFloatNoTag(value: oneValuegeometryPoint)
        }
      }
      if hasTrLevel {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:trLevel)
      }
      if hasLength {
        try codedOutputStream.writeFloat(fieldNumber: 4, value:length)
      }
      if hasSpeed {
        try codedOutputStream.writeFloat(fieldNumber: 5, value:speed)
      }
      if hasFfs {
        try codedOutputStream.writeFloat(fieldNumber: 6, value:ffs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasEdgeId {
        serialize_size += edgeId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizeGeometryPoint:Int32 = 0
      dataSizeGeometryPoint = 4 * Int32(geometryPoint.count)
      serialize_size += dataSizeGeometryPoint
      if !geometryPoint.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeGeometryPoint.computeInt32SizeNoTag()
      }
      geometryPointMemoizedSerializedSize = dataSizeGeometryPoint
      if hasTrLevel {
        serialize_size += trLevel.computeInt32Size(fieldNumber: 3)
      }
      if hasLength {
        serialize_size += length.computeFloatSize(fieldNumber: 4)
      }
      if hasSpeed {
        serialize_size += speed.computeFloatSize(fieldNumber: 5)
      }
      if hasFfs {
        serialize_size += ffs.computeFloatSize(fieldNumber: 6)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
      return Duel.Pta.Api.PtaassistantEdgePb.classBuilder() as! Duel.Pta.Api.PtaassistantEdgePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantEdgePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantEdgePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantEdgePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
      return try Duel.Pta.Api.PtaassistantEdgePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantEdgePb) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
      return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasEdgeId {
        jsonMap["edgeId"] = Int(edgeId)
      }
      if !geometryPoint.isEmpty {
        var jsonArrayGeometryPoint:Array<Float> = []
          for oneValueGeometryPoint in geometryPoint {
            jsonArrayGeometryPoint.append(Float(oneValueGeometryPoint))
          }
        jsonMap["geometryPoint"] = jsonArrayGeometryPoint
      }
      if hasTrLevel {
        jsonMap["trLevel"] = Int(trLevel)
      }
      if hasLength {
        jsonMap["length"] = Float(length)
      }
      if hasSpeed {
        jsonMap["speed"] = Float(speed)
      }
      if hasFfs {
        jsonMap["ffs"] = Float(ffs)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantEdgePb {
      return try Duel.Pta.Api.PtaassistantEdgePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantEdgePb {
      return try Duel.Pta.Api.PtaassistantEdgePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasEdgeId {
        output += "\(indent) edgeId: \(edgeId) \n"
      }
      var geometryPointElementIndex:Int = 0
      for oneValueGeometryPoint in geometryPoint  {
          output += "\(indent) geometryPoint[\(geometryPointElementIndex)]: \(oneValueGeometryPoint)\n"
          geometryPointElementIndex += 1
      }
      if hasTrLevel {
        output += "\(indent) trLevel: \(trLevel) \n"
      }
      if hasLength {
        output += "\(indent) length: \(length) \n"
      }
      if hasSpeed {
        output += "\(indent) speed: \(speed) \n"
      }
      if hasFfs {
        output += "\(indent) ffs: \(ffs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasEdgeId {
               hashCode = (hashCode &* 31) &+ edgeId.hashValue
            }
            for oneValueGeometryPoint in geometryPoint {
                hashCode = (hashCode &* 31) &+ oneValueGeometryPoint.hashValue
            }
            if hasTrLevel {
               hashCode = (hashCode &* 31) &+ trLevel.hashValue
            }
            if hasLength {
               hashCode = (hashCode &* 31) &+ length.hashValue
            }
            if hasSpeed {
               hashCode = (hashCode &* 31) &+ speed.hashValue
            }
            if hasFfs {
               hashCode = (hashCode &* 31) &+ ffs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantEdgePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantEdgePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantEdgePb = Duel.Pta.Api.PtaassistantEdgePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantEdgePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasEdgeId:Bool {
           get {
                return builderResult.hasEdgeId
           }
      }
      public var edgeId:Int32 {
           get {
                return builderResult.edgeId
           }
           set (value) {
               builderResult.hasEdgeId = true
               builderResult.edgeId = value
           }
      }
      @discardableResult
      public func setEdgeId(_ value:Int32) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.edgeId = value
        return self
      }
      @discardableResult
      public func clearEdgeId() -> Duel.Pta.Api.PtaassistantEdgePb.Builder{
           builderResult.hasEdgeId = false
           builderResult.edgeId = Int32(0)
           return self
      }
      public var geometryPoint:Array<Float> {
           get {
               return builderResult.geometryPoint
           }
           set (array) {
               builderResult.geometryPoint = array
           }
      }
      @discardableResult
      public func setGeometryPoint(_ value:Array<Float>) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.geometryPoint = value
        return self
      }
      @discardableResult
      public func clearGeometryPoint() -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
         builderResult.geometryPoint.removeAll(keepingCapacity: false)
         return self
      }
      public var hasTrLevel:Bool {
           get {
                return builderResult.hasTrLevel
           }
      }
      public var trLevel:Int32 {
           get {
                return builderResult.trLevel
           }
           set (value) {
               builderResult.hasTrLevel = true
               builderResult.trLevel = value
           }
      }
      @discardableResult
      public func setTrLevel(_ value:Int32) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.trLevel = value
        return self
      }
      @discardableResult
      public func clearTrLevel() -> Duel.Pta.Api.PtaassistantEdgePb.Builder{
           builderResult.hasTrLevel = false
           builderResult.trLevel = Int32(0)
           return self
      }
      public var hasLength:Bool {
           get {
                return builderResult.hasLength
           }
      }
      public var length:Float {
           get {
                return builderResult.length
           }
           set (value) {
               builderResult.hasLength = true
               builderResult.length = value
           }
      }
      @discardableResult
      public func setLength(_ value:Float) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.length = value
        return self
      }
      @discardableResult
      public func clearLength() -> Duel.Pta.Api.PtaassistantEdgePb.Builder{
           builderResult.hasLength = false
           builderResult.length = Float(0)
           return self
      }
      public var hasSpeed:Bool {
           get {
                return builderResult.hasSpeed
           }
      }
      public var speed:Float {
           get {
                return builderResult.speed
           }
           set (value) {
               builderResult.hasSpeed = true
               builderResult.speed = value
           }
      }
      @discardableResult
      public func setSpeed(_ value:Float) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.speed = value
        return self
      }
      @discardableResult
      public func clearSpeed() -> Duel.Pta.Api.PtaassistantEdgePb.Builder{
           builderResult.hasSpeed = false
           builderResult.speed = Float(0)
           return self
      }
      public var hasFfs:Bool {
           get {
                return builderResult.hasFfs
           }
      }
      public var ffs:Float {
           get {
                return builderResult.ffs
           }
           set (value) {
               builderResult.hasFfs = true
               builderResult.ffs = value
           }
      }
      @discardableResult
      public func setFfs(_ value:Float) -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        self.ffs = value
        return self
      }
      @discardableResult
      public func clearFfs() -> Duel.Pta.Api.PtaassistantEdgePb.Builder{
           builderResult.hasFfs = false
           builderResult.ffs = Float(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantEdgePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        return try Duel.Pta.Api.PtaassistantEdgePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantEdgePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantEdgePb {
        let returnMe:Duel.Pta.Api.PtaassistantEdgePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantEdgePb) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        if other == Duel.Pta.Api.PtaassistantEdgePb() {
         return self
        }
        if other.hasEdgeId {
             edgeId = other.edgeId
        }
        if !other.geometryPoint.isEmpty {
            builderResult.geometryPoint += other.geometryPoint
        }
        if other.hasTrLevel {
             trLevel = other.trLevel
        }
        if other.hasLength {
             length = other.length
        }
        if other.hasSpeed {
             speed = other.speed
        }
        if other.hasFfs {
             ffs = other.ffs
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            edgeId = try codedInputStream.readInt32()

          case 18:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.geometryPoint.append(try codedInputStream.readFloat())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 24:
            trLevel = try codedInputStream.readInt32()

          case 37:
            length = try codedInputStream.readFloat()

          case 45:
            speed = try codedInputStream.readFloat()

          case 53:
            ffs = try codedInputStream.readFloat()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantEdgePb.Builder()
        if let jsonValueEdgeId = jsonMap["edgeId"] as? Int {
          resultDecodedBuilder.edgeId = Int32(jsonValueEdgeId)
        } else if let jsonValueEdgeId = jsonMap["edgeId"] as? String {
          resultDecodedBuilder.edgeId = Int32(jsonValueEdgeId)!
        }
        if let jsonValueGeometryPoint = jsonMap["geometryPoint"] as? Array<Float> {
          var jsonArrayGeometryPoint:Array<Float> = []
          for oneValueGeometryPoint in jsonValueGeometryPoint {
            jsonArrayGeometryPoint.append(Float(oneValueGeometryPoint))
          }
          resultDecodedBuilder.geometryPoint = jsonArrayGeometryPoint
        }
        if let jsonValueTrLevel = jsonMap["trLevel"] as? Int {
          resultDecodedBuilder.trLevel = Int32(jsonValueTrLevel)
        } else if let jsonValueTrLevel = jsonMap["trLevel"] as? String {
          resultDecodedBuilder.trLevel = Int32(jsonValueTrLevel)!
        }
        if let jsonValueLength = jsonMap["length"] as? Float {
          resultDecodedBuilder.length = Float(jsonValueLength)
        } else if let jsonValueLength = jsonMap["length"] as? String {
          resultDecodedBuilder.length = Float(jsonValueLength)!
        }
        if let jsonValueSpeed = jsonMap["speed"] as? Float {
          resultDecodedBuilder.speed = Float(jsonValueSpeed)
        } else if let jsonValueSpeed = jsonMap["speed"] as? String {
          resultDecodedBuilder.speed = Float(jsonValueSpeed)!
        }
        if let jsonValueFfs = jsonMap["ffs"] as? Float {
          resultDecodedBuilder.ffs = Float(jsonValueFfs)
        } else if let jsonValueFfs = jsonMap["ffs"] as? String {
          resultDecodedBuilder.ffs = Float(jsonValueFfs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantEdgePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantEdgePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantEventPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantEventPb, rhs: Duel.Pta.Api.PtaassistantEventPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasEventId == rhs.hasEventId) && (!lhs.hasEventId || lhs.eventId == rhs.eventId)
      fieldCheck = fieldCheck && (lhs.hasEvent == rhs.hasEvent) && (!lhs.hasEvent || lhs.event == rhs.event)
      fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
      fieldCheck = fieldCheck && (lhs.hasNote == rhs.hasNote) && (!lhs.hasNote || lhs.note == rhs.note)
      fieldCheck = fieldCheck && (lhs.hasIconId == rhs.hasIconId) && (!lhs.hasIconId || lhs.iconId == rhs.iconId)
      fieldCheck = fieldCheck && (lhs.hasLon == rhs.hasLon) && (!lhs.hasLon || lhs.lon == rhs.lon)
      fieldCheck = fieldCheck && (lhs.hasLat == rhs.hasLat) && (!lhs.hasLat || lhs.lat == rhs.lat)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var eventId:String = ""
    public fileprivate(set) var hasEventId:Bool = false

    public fileprivate(set) var event:String = ""
    public fileprivate(set) var hasEvent:Bool = false

    public fileprivate(set) var location:String = ""
    public fileprivate(set) var hasLocation:Bool = false

    public fileprivate(set) var note:String = ""
    public fileprivate(set) var hasNote:Bool = false

    public fileprivate(set) var iconId:String = ""
    public fileprivate(set) var hasIconId:Bool = false

    public fileprivate(set) var lon:Float = Float(0)
    public fileprivate(set) var hasLon:Bool = false

    public fileprivate(set) var lat:Float = Float(0)
    public fileprivate(set) var hasLat:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasEventId {
        try codedOutputStream.writeString(fieldNumber: 1, value:eventId)
      }
      if hasEvent {
        try codedOutputStream.writeString(fieldNumber: 2, value:event)
      }
      if hasLocation {
        try codedOutputStream.writeString(fieldNumber: 3, value:location)
      }
      if hasNote {
        try codedOutputStream.writeString(fieldNumber: 4, value:note)
      }
      if hasIconId {
        try codedOutputStream.writeString(fieldNumber: 5, value:iconId)
      }
      if hasLon {
        try codedOutputStream.writeFloat(fieldNumber: 6, value:lon)
      }
      if hasLat {
        try codedOutputStream.writeFloat(fieldNumber: 7, value:lat)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasEventId {
        serialize_size += eventId.computeStringSize(fieldNumber: 1)
      }
      if hasEvent {
        serialize_size += event.computeStringSize(fieldNumber: 2)
      }
      if hasLocation {
        serialize_size += location.computeStringSize(fieldNumber: 3)
      }
      if hasNote {
        serialize_size += note.computeStringSize(fieldNumber: 4)
      }
      if hasIconId {
        serialize_size += iconId.computeStringSize(fieldNumber: 5)
      }
      if hasLon {
        serialize_size += lon.computeFloatSize(fieldNumber: 6)
      }
      if hasLat {
        serialize_size += lat.computeFloatSize(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantEventPb.Builder {
      return Duel.Pta.Api.PtaassistantEventPb.classBuilder() as! Duel.Pta.Api.PtaassistantEventPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantEventPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantEventPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantEventPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantEventPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
      return try Duel.Pta.Api.PtaassistantEventPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantEventPb) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
      return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasEventId {
        jsonMap["eventId"] = eventId
      }
      if hasEvent {
        jsonMap["event"] = event
      }
      if hasLocation {
        jsonMap["location"] = location
      }
      if hasNote {
        jsonMap["note"] = note
      }
      if hasIconId {
        jsonMap["iconId"] = iconId
      }
      if hasLon {
        jsonMap["lon"] = Float(lon)
      }
      if hasLat {
        jsonMap["lat"] = Float(lat)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantEventPb {
      return try Duel.Pta.Api.PtaassistantEventPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantEventPb {
      return try Duel.Pta.Api.PtaassistantEventPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasEventId {
        output += "\(indent) eventId: \(eventId) \n"
      }
      if hasEvent {
        output += "\(indent) event: \(event) \n"
      }
      if hasLocation {
        output += "\(indent) location: \(location) \n"
      }
      if hasNote {
        output += "\(indent) note: \(note) \n"
      }
      if hasIconId {
        output += "\(indent) iconId: \(iconId) \n"
      }
      if hasLon {
        output += "\(indent) lon: \(lon) \n"
      }
      if hasLat {
        output += "\(indent) lat: \(lat) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasEventId {
               hashCode = (hashCode &* 31) &+ eventId.hashValue
            }
            if hasEvent {
               hashCode = (hashCode &* 31) &+ event.hashValue
            }
            if hasLocation {
               hashCode = (hashCode &* 31) &+ location.hashValue
            }
            if hasNote {
               hashCode = (hashCode &* 31) &+ note.hashValue
            }
            if hasIconId {
               hashCode = (hashCode &* 31) &+ iconId.hashValue
            }
            if hasLon {
               hashCode = (hashCode &* 31) &+ lon.hashValue
            }
            if hasLat {
               hashCode = (hashCode &* 31) &+ lat.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantEventPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantEventPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantEventPb = Duel.Pta.Api.PtaassistantEventPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantEventPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasEventId:Bool {
           get {
                return builderResult.hasEventId
           }
      }
      public var eventId:String {
           get {
                return builderResult.eventId
           }
           set (value) {
               builderResult.hasEventId = true
               builderResult.eventId = value
           }
      }
      @discardableResult
      public func setEventId(_ value:String) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.eventId = value
        return self
      }
      @discardableResult
      public func clearEventId() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasEventId = false
           builderResult.eventId = ""
           return self
      }
      public var hasEvent:Bool {
           get {
                return builderResult.hasEvent
           }
      }
      public var event:String {
           get {
                return builderResult.event
           }
           set (value) {
               builderResult.hasEvent = true
               builderResult.event = value
           }
      }
      @discardableResult
      public func setEvent(_ value:String) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.event = value
        return self
      }
      @discardableResult
      public func clearEvent() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasEvent = false
           builderResult.event = ""
           return self
      }
      public var hasLocation:Bool {
           get {
                return builderResult.hasLocation
           }
      }
      public var location:String {
           get {
                return builderResult.location
           }
           set (value) {
               builderResult.hasLocation = true
               builderResult.location = value
           }
      }
      @discardableResult
      public func setLocation(_ value:String) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.location = value
        return self
      }
      @discardableResult
      public func clearLocation() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasLocation = false
           builderResult.location = ""
           return self
      }
      public var hasNote:Bool {
           get {
                return builderResult.hasNote
           }
      }
      public var note:String {
           get {
                return builderResult.note
           }
           set (value) {
               builderResult.hasNote = true
               builderResult.note = value
           }
      }
      @discardableResult
      public func setNote(_ value:String) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.note = value
        return self
      }
      @discardableResult
      public func clearNote() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasNote = false
           builderResult.note = ""
           return self
      }
      public var hasIconId:Bool {
           get {
                return builderResult.hasIconId
           }
      }
      public var iconId:String {
           get {
                return builderResult.iconId
           }
           set (value) {
               builderResult.hasIconId = true
               builderResult.iconId = value
           }
      }
      @discardableResult
      public func setIconId(_ value:String) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.iconId = value
        return self
      }
      @discardableResult
      public func clearIconId() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasIconId = false
           builderResult.iconId = ""
           return self
      }
      public var hasLon:Bool {
           get {
                return builderResult.hasLon
           }
      }
      public var lon:Float {
           get {
                return builderResult.lon
           }
           set (value) {
               builderResult.hasLon = true
               builderResult.lon = value
           }
      }
      @discardableResult
      public func setLon(_ value:Float) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.lon = value
        return self
      }
      @discardableResult
      public func clearLon() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasLon = false
           builderResult.lon = Float(0)
           return self
      }
      public var hasLat:Bool {
           get {
                return builderResult.hasLat
           }
      }
      public var lat:Float {
           get {
                return builderResult.lat
           }
           set (value) {
               builderResult.hasLat = true
               builderResult.lat = value
           }
      }
      @discardableResult
      public func setLat(_ value:Float) -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        self.lat = value
        return self
      }
      @discardableResult
      public func clearLat() -> Duel.Pta.Api.PtaassistantEventPb.Builder{
           builderResult.hasLat = false
           builderResult.lat = Float(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantEventPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        return try Duel.Pta.Api.PtaassistantEventPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantEventPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantEventPb {
        let returnMe:Duel.Pta.Api.PtaassistantEventPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantEventPb) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        if other == Duel.Pta.Api.PtaassistantEventPb() {
         return self
        }
        if other.hasEventId {
             eventId = other.eventId
        }
        if other.hasEvent {
             event = other.event
        }
        if other.hasLocation {
             location = other.location
        }
        if other.hasNote {
             note = other.note
        }
        if other.hasIconId {
             iconId = other.iconId
        }
        if other.hasLon {
             lon = other.lon
        }
        if other.hasLat {
             lat = other.lat
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            eventId = try codedInputStream.readString()

          case 18:
            event = try codedInputStream.readString()

          case 26:
            location = try codedInputStream.readString()

          case 34:
            note = try codedInputStream.readString()

          case 42:
            iconId = try codedInputStream.readString()

          case 53:
            lon = try codedInputStream.readFloat()

          case 61:
            lat = try codedInputStream.readFloat()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantEventPb.Builder()
        if let jsonValueEventId = jsonMap["eventId"] as? String {
          resultDecodedBuilder.eventId = jsonValueEventId
        }
        if let jsonValueEvent = jsonMap["event"] as? String {
          resultDecodedBuilder.event = jsonValueEvent
        }
        if let jsonValueLocation = jsonMap["location"] as? String {
          resultDecodedBuilder.location = jsonValueLocation
        }
        if let jsonValueNote = jsonMap["note"] as? String {
          resultDecodedBuilder.note = jsonValueNote
        }
        if let jsonValueIconId = jsonMap["iconId"] as? String {
          resultDecodedBuilder.iconId = jsonValueIconId
        }
        if let jsonValueLon = jsonMap["lon"] as? Float {
          resultDecodedBuilder.lon = Float(jsonValueLon)
        } else if let jsonValueLon = jsonMap["lon"] as? String {
          resultDecodedBuilder.lon = Float(jsonValueLon)!
        }
        if let jsonValueLat = jsonMap["lat"] as? Float {
          resultDecodedBuilder.lat = Float(jsonValueLat)
        } else if let jsonValueLat = jsonMap["lat"] as? String {
          resultDecodedBuilder.lat = Float(jsonValueLat)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantEventPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantEventPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantLosEventPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantLosEventPb, rhs: Duel.Pta.Api.PtaassistantLosEventPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasLosEventId == rhs.hasLosEventId) && (!lhs.hasLosEventId || lhs.losEventId == rhs.losEventId)
      fieldCheck = fieldCheck && (lhs.edgeIds == rhs.edgeIds)
      fieldCheck = fieldCheck && (lhs.hasInReport == rhs.hasInReport) && (!lhs.hasInReport || lhs.inReport == rhs.inReport)
      fieldCheck = fieldCheck && (lhs.hasNearReport == rhs.hasNearReport) && (!lhs.hasNearReport || lhs.nearReport == rhs.nearReport)
      fieldCheck = fieldCheck && (lhs.hasFarReport == rhs.hasFarReport) && (!lhs.hasFarReport || lhs.farReport == rhs.farReport)
      fieldCheck = fieldCheck && (lhs.hasInOffset == rhs.hasInOffset) && (!lhs.hasInOffset || lhs.inOffset == rhs.inOffset)
      fieldCheck = fieldCheck && (lhs.hasNearOffset == rhs.hasNearOffset) && (!lhs.hasNearOffset || lhs.nearOffset == rhs.nearOffset)
      fieldCheck = fieldCheck && (lhs.hasFarOffset == rhs.hasFarOffset) && (!lhs.hasFarOffset || lhs.farOffset == rhs.farOffset)
      fieldCheck = fieldCheck && (lhs.hasLength == rhs.hasLength) && (!lhs.hasLength || lhs.length == rhs.length)
      fieldCheck = fieldCheck && (lhs.hasSeverity == rhs.hasSeverity) && (!lhs.hasSeverity || lhs.severity == rhs.severity)
      fieldCheck = fieldCheck && (lhs.hasFromSegmentId == rhs.hasFromSegmentId) && (!lhs.hasFromSegmentId || lhs.fromSegmentId == rhs.fromSegmentId)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var losEventId:Int32 = Int32(0)
    public fileprivate(set) var hasLosEventId:Bool = false

    public fileprivate(set) var edgeIds:Array<Int32> = Array<Int32>()
    //descrizione dell'evento IN
    public fileprivate(set) var inReport:String = ""
    public fileprivate(set) var hasInReport:Bool = false

    //descrizione dell'evento NEAR
    public fileprivate(set) var nearReport:String = ""
    public fileprivate(set) var hasNearReport:Bool = false

    //descrizione dell'evento FAR
    public fileprivate(set) var farReport:String = ""
    public fileprivate(set) var hasFarReport:Bool = false

    //distanza dell'inizio dell'evento dall'inizio del segmento
    public fileprivate(set) var inOffset:Float = Float(0)
    public fileprivate(set) var hasInOffset:Bool = false

    //la distanza del near dell'evento dall'inizio del segmento
    public fileprivate(set) var nearOffset:Float = Float(0)
    public fileprivate(set) var hasNearOffset:Bool = false

    //la distanza del far dell'evento dall'inizio del segmento
    public fileprivate(set) var farOffset:Float = Float(0)
    public fileprivate(set) var hasFarOffset:Bool = false

    //lunghezza dell'evento
    public fileprivate(set) var length:Float = Float(0)
    public fileprivate(set) var hasLength:Bool = false

    public fileprivate(set) var severity:Int32 = Int32(0)
    public fileprivate(set) var hasSeverity:Bool = false

    // Campo riservato per i los dei nodi che indica il segmento di proveninenza
    public fileprivate(set) var fromSegmentId:Int32 = Int32(0)
    public fileprivate(set) var hasFromSegmentId:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasLosEventId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:losEventId)
      }
      if !edgeIds.isEmpty {
        for oneValueedgeIds in edgeIds {
          try codedOutputStream.writeInt32(fieldNumber: 2, value:oneValueedgeIds)
        }
      }
      if hasInReport {
        try codedOutputStream.writeString(fieldNumber: 3, value:inReport)
      }
      if hasNearReport {
        try codedOutputStream.writeString(fieldNumber: 4, value:nearReport)
      }
      if hasFarReport {
        try codedOutputStream.writeString(fieldNumber: 5, value:farReport)
      }
      if hasInOffset {
        try codedOutputStream.writeFloat(fieldNumber: 6, value:inOffset)
      }
      if hasNearOffset {
        try codedOutputStream.writeFloat(fieldNumber: 7, value:nearOffset)
      }
      if hasFarOffset {
        try codedOutputStream.writeFloat(fieldNumber: 8, value:farOffset)
      }
      if hasLength {
        try codedOutputStream.writeFloat(fieldNumber: 9, value:length)
      }
      if hasSeverity {
        try codedOutputStream.writeInt32(fieldNumber: 10, value:severity)
      }
      if hasFromSegmentId {
        try codedOutputStream.writeInt32(fieldNumber: 11, value:fromSegmentId)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasLosEventId {
        serialize_size += losEventId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizeEdgeIds:Int32 = 0
      for oneValueedgeIds in edgeIds {
          dataSizeEdgeIds += oneValueedgeIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeEdgeIds
      serialize_size += 1 * Int32(edgeIds.count)
      if hasInReport {
        serialize_size += inReport.computeStringSize(fieldNumber: 3)
      }
      if hasNearReport {
        serialize_size += nearReport.computeStringSize(fieldNumber: 4)
      }
      if hasFarReport {
        serialize_size += farReport.computeStringSize(fieldNumber: 5)
      }
      if hasInOffset {
        serialize_size += inOffset.computeFloatSize(fieldNumber: 6)
      }
      if hasNearOffset {
        serialize_size += nearOffset.computeFloatSize(fieldNumber: 7)
      }
      if hasFarOffset {
        serialize_size += farOffset.computeFloatSize(fieldNumber: 8)
      }
      if hasLength {
        serialize_size += length.computeFloatSize(fieldNumber: 9)
      }
      if hasSeverity {
        serialize_size += severity.computeInt32Size(fieldNumber: 10)
      }
      if hasFromSegmentId {
        serialize_size += fromSegmentId.computeInt32Size(fieldNumber: 11)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
      return Duel.Pta.Api.PtaassistantLosEventPb.classBuilder() as! Duel.Pta.Api.PtaassistantLosEventPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantLosEventPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLosEventPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLosEventPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
      return try Duel.Pta.Api.PtaassistantLosEventPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantLosEventPb) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
      return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasLosEventId {
        jsonMap["losEventId"] = Int(losEventId)
      }
      if !edgeIds.isEmpty {
        var jsonArrayEdgeIds:Array<Int> = []
          for oneValueEdgeIds in edgeIds {
            jsonArrayEdgeIds.append(Int(oneValueEdgeIds))
          }
        jsonMap["edgeIds"] = jsonArrayEdgeIds
      }
      if hasInReport {
        jsonMap["inReport"] = inReport
      }
      if hasNearReport {
        jsonMap["nearReport"] = nearReport
      }
      if hasFarReport {
        jsonMap["farReport"] = farReport
      }
      if hasInOffset {
        jsonMap["inOffset"] = Float(inOffset)
      }
      if hasNearOffset {
        jsonMap["nearOffset"] = Float(nearOffset)
      }
      if hasFarOffset {
        jsonMap["farOffset"] = Float(farOffset)
      }
      if hasLength {
        jsonMap["length"] = Float(length)
      }
      if hasSeverity {
        jsonMap["severity"] = Int(severity)
      }
      if hasFromSegmentId {
        jsonMap["fromSegmentId"] = Int(fromSegmentId)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
      return try Duel.Pta.Api.PtaassistantLosEventPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
      return try Duel.Pta.Api.PtaassistantLosEventPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasLosEventId {
        output += "\(indent) losEventId: \(losEventId) \n"
      }
      var edgeIdsElementIndex:Int = 0
      for oneValueEdgeIds in edgeIds  {
          output += "\(indent) edgeIds[\(edgeIdsElementIndex)]: \(oneValueEdgeIds)\n"
          edgeIdsElementIndex += 1
      }
      if hasInReport {
        output += "\(indent) inReport: \(inReport) \n"
      }
      if hasNearReport {
        output += "\(indent) nearReport: \(nearReport) \n"
      }
      if hasFarReport {
        output += "\(indent) farReport: \(farReport) \n"
      }
      if hasInOffset {
        output += "\(indent) inOffset: \(inOffset) \n"
      }
      if hasNearOffset {
        output += "\(indent) nearOffset: \(nearOffset) \n"
      }
      if hasFarOffset {
        output += "\(indent) farOffset: \(farOffset) \n"
      }
      if hasLength {
        output += "\(indent) length: \(length) \n"
      }
      if hasSeverity {
        output += "\(indent) severity: \(severity) \n"
      }
      if hasFromSegmentId {
        output += "\(indent) fromSegmentId: \(fromSegmentId) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasLosEventId {
               hashCode = (hashCode &* 31) &+ losEventId.hashValue
            }
            for oneValueEdgeIds in edgeIds {
                hashCode = (hashCode &* 31) &+ oneValueEdgeIds.hashValue
            }
            if hasInReport {
               hashCode = (hashCode &* 31) &+ inReport.hashValue
            }
            if hasNearReport {
               hashCode = (hashCode &* 31) &+ nearReport.hashValue
            }
            if hasFarReport {
               hashCode = (hashCode &* 31) &+ farReport.hashValue
            }
            if hasInOffset {
               hashCode = (hashCode &* 31) &+ inOffset.hashValue
            }
            if hasNearOffset {
               hashCode = (hashCode &* 31) &+ nearOffset.hashValue
            }
            if hasFarOffset {
               hashCode = (hashCode &* 31) &+ farOffset.hashValue
            }
            if hasLength {
               hashCode = (hashCode &* 31) &+ length.hashValue
            }
            if hasSeverity {
               hashCode = (hashCode &* 31) &+ severity.hashValue
            }
            if hasFromSegmentId {
               hashCode = (hashCode &* 31) &+ fromSegmentId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantLosEventPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantLosEventPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantLosEventPb = Duel.Pta.Api.PtaassistantLosEventPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantLosEventPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasLosEventId:Bool {
           get {
                return builderResult.hasLosEventId
           }
      }
      public var losEventId:Int32 {
           get {
                return builderResult.losEventId
           }
           set (value) {
               builderResult.hasLosEventId = true
               builderResult.losEventId = value
           }
      }
      @discardableResult
      public func setLosEventId(_ value:Int32) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.losEventId = value
        return self
      }
      @discardableResult
      public func clearLosEventId() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasLosEventId = false
           builderResult.losEventId = Int32(0)
           return self
      }
      public var edgeIds:Array<Int32> {
           get {
               return builderResult.edgeIds
           }
           set (array) {
               builderResult.edgeIds = array
           }
      }
      @discardableResult
      public func setEdgeIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.edgeIds = value
        return self
      }
      @discardableResult
      public func clearEdgeIds() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
         builderResult.edgeIds.removeAll(keepingCapacity: false)
         return self
      }
      public var hasInReport:Bool {
           get {
                return builderResult.hasInReport
           }
      }
      public var inReport:String {
           get {
                return builderResult.inReport
           }
           set (value) {
               builderResult.hasInReport = true
               builderResult.inReport = value
           }
      }
      @discardableResult
      public func setInReport(_ value:String) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.inReport = value
        return self
      }
      @discardableResult
      public func clearInReport() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasInReport = false
           builderResult.inReport = ""
           return self
      }
      public var hasNearReport:Bool {
           get {
                return builderResult.hasNearReport
           }
      }
      public var nearReport:String {
           get {
                return builderResult.nearReport
           }
           set (value) {
               builderResult.hasNearReport = true
               builderResult.nearReport = value
           }
      }
      @discardableResult
      public func setNearReport(_ value:String) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.nearReport = value
        return self
      }
      @discardableResult
      public func clearNearReport() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasNearReport = false
           builderResult.nearReport = ""
           return self
      }
      public var hasFarReport:Bool {
           get {
                return builderResult.hasFarReport
           }
      }
      public var farReport:String {
           get {
                return builderResult.farReport
           }
           set (value) {
               builderResult.hasFarReport = true
               builderResult.farReport = value
           }
      }
      @discardableResult
      public func setFarReport(_ value:String) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.farReport = value
        return self
      }
      @discardableResult
      public func clearFarReport() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasFarReport = false
           builderResult.farReport = ""
           return self
      }
      public var hasInOffset:Bool {
           get {
                return builderResult.hasInOffset
           }
      }
      public var inOffset:Float {
           get {
                return builderResult.inOffset
           }
           set (value) {
               builderResult.hasInOffset = true
               builderResult.inOffset = value
           }
      }
      @discardableResult
      public func setInOffset(_ value:Float) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.inOffset = value
        return self
      }
      @discardableResult
      public func clearInOffset() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasInOffset = false
           builderResult.inOffset = Float(0)
           return self
      }
      public var hasNearOffset:Bool {
           get {
                return builderResult.hasNearOffset
           }
      }
      public var nearOffset:Float {
           get {
                return builderResult.nearOffset
           }
           set (value) {
               builderResult.hasNearOffset = true
               builderResult.nearOffset = value
           }
      }
      @discardableResult
      public func setNearOffset(_ value:Float) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.nearOffset = value
        return self
      }
      @discardableResult
      public func clearNearOffset() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasNearOffset = false
           builderResult.nearOffset = Float(0)
           return self
      }
      public var hasFarOffset:Bool {
           get {
                return builderResult.hasFarOffset
           }
      }
      public var farOffset:Float {
           get {
                return builderResult.farOffset
           }
           set (value) {
               builderResult.hasFarOffset = true
               builderResult.farOffset = value
           }
      }
      @discardableResult
      public func setFarOffset(_ value:Float) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.farOffset = value
        return self
      }
      @discardableResult
      public func clearFarOffset() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasFarOffset = false
           builderResult.farOffset = Float(0)
           return self
      }
      public var hasLength:Bool {
           get {
                return builderResult.hasLength
           }
      }
      public var length:Float {
           get {
                return builderResult.length
           }
           set (value) {
               builderResult.hasLength = true
               builderResult.length = value
           }
      }
      @discardableResult
      public func setLength(_ value:Float) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.length = value
        return self
      }
      @discardableResult
      public func clearLength() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasLength = false
           builderResult.length = Float(0)
           return self
      }
      public var hasSeverity:Bool {
           get {
                return builderResult.hasSeverity
           }
      }
      public var severity:Int32 {
           get {
                return builderResult.severity
           }
           set (value) {
               builderResult.hasSeverity = true
               builderResult.severity = value
           }
      }
      @discardableResult
      public func setSeverity(_ value:Int32) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.severity = value
        return self
      }
      @discardableResult
      public func clearSeverity() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasSeverity = false
           builderResult.severity = Int32(0)
           return self
      }
      public var hasFromSegmentId:Bool {
           get {
                return builderResult.hasFromSegmentId
           }
      }
      public var fromSegmentId:Int32 {
           get {
                return builderResult.fromSegmentId
           }
           set (value) {
               builderResult.hasFromSegmentId = true
               builderResult.fromSegmentId = value
           }
      }
      @discardableResult
      public func setFromSegmentId(_ value:Int32) -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        self.fromSegmentId = value
        return self
      }
      @discardableResult
      public func clearFromSegmentId() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder{
           builderResult.hasFromSegmentId = false
           builderResult.fromSegmentId = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantLosEventPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        return try Duel.Pta.Api.PtaassistantLosEventPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantLosEventPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantLosEventPb {
        let returnMe:Duel.Pta.Api.PtaassistantLosEventPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantLosEventPb) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        if other == Duel.Pta.Api.PtaassistantLosEventPb() {
         return self
        }
        if other.hasLosEventId {
             losEventId = other.losEventId
        }
        if !other.edgeIds.isEmpty {
            builderResult.edgeIds += other.edgeIds
        }
        if other.hasInReport {
             inReport = other.inReport
        }
        if other.hasNearReport {
             nearReport = other.nearReport
        }
        if other.hasFarReport {
             farReport = other.farReport
        }
        if other.hasInOffset {
             inOffset = other.inOffset
        }
        if other.hasNearOffset {
             nearOffset = other.nearOffset
        }
        if other.hasFarOffset {
             farOffset = other.farOffset
        }
        if other.hasLength {
             length = other.length
        }
        if other.hasSeverity {
             severity = other.severity
        }
        if other.hasFromSegmentId {
             fromSegmentId = other.fromSegmentId
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            losEventId = try codedInputStream.readInt32()

          case 16:
            edgeIds += [try codedInputStream.readInt32()]

          case 26:
            inReport = try codedInputStream.readString()

          case 34:
            nearReport = try codedInputStream.readString()

          case 42:
            farReport = try codedInputStream.readString()

          case 53:
            inOffset = try codedInputStream.readFloat()

          case 61:
            nearOffset = try codedInputStream.readFloat()

          case 69:
            farOffset = try codedInputStream.readFloat()

          case 77:
            length = try codedInputStream.readFloat()

          case 80:
            severity = try codedInputStream.readInt32()

          case 88:
            fromSegmentId = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantLosEventPb.Builder()
        if let jsonValueLosEventId = jsonMap["losEventId"] as? Int {
          resultDecodedBuilder.losEventId = Int32(jsonValueLosEventId)
        } else if let jsonValueLosEventId = jsonMap["losEventId"] as? String {
          resultDecodedBuilder.losEventId = Int32(jsonValueLosEventId)!
        }
        if let jsonValueEdgeIds = jsonMap["edgeIds"] as? Array<Int> {
          var jsonArrayEdgeIds:Array<Int32> = []
          for oneValueEdgeIds in jsonValueEdgeIds {
            jsonArrayEdgeIds.append(Int32(oneValueEdgeIds))
          }
          resultDecodedBuilder.edgeIds = jsonArrayEdgeIds
        }
        if let jsonValueInReport = jsonMap["inReport"] as? String {
          resultDecodedBuilder.inReport = jsonValueInReport
        }
        if let jsonValueNearReport = jsonMap["nearReport"] as? String {
          resultDecodedBuilder.nearReport = jsonValueNearReport
        }
        if let jsonValueFarReport = jsonMap["farReport"] as? String {
          resultDecodedBuilder.farReport = jsonValueFarReport
        }
        if let jsonValueInOffset = jsonMap["inOffset"] as? Float {
          resultDecodedBuilder.inOffset = Float(jsonValueInOffset)
        } else if let jsonValueInOffset = jsonMap["inOffset"] as? String {
          resultDecodedBuilder.inOffset = Float(jsonValueInOffset)!
        }
        if let jsonValueNearOffset = jsonMap["nearOffset"] as? Float {
          resultDecodedBuilder.nearOffset = Float(jsonValueNearOffset)
        } else if let jsonValueNearOffset = jsonMap["nearOffset"] as? String {
          resultDecodedBuilder.nearOffset = Float(jsonValueNearOffset)!
        }
        if let jsonValueFarOffset = jsonMap["farOffset"] as? Float {
          resultDecodedBuilder.farOffset = Float(jsonValueFarOffset)
        } else if let jsonValueFarOffset = jsonMap["farOffset"] as? String {
          resultDecodedBuilder.farOffset = Float(jsonValueFarOffset)!
        }
        if let jsonValueLength = jsonMap["length"] as? Float {
          resultDecodedBuilder.length = Float(jsonValueLength)
        } else if let jsonValueLength = jsonMap["length"] as? String {
          resultDecodedBuilder.length = Float(jsonValueLength)!
        }
        if let jsonValueSeverity = jsonMap["severity"] as? Int {
          resultDecodedBuilder.severity = Int32(jsonValueSeverity)
        } else if let jsonValueSeverity = jsonMap["severity"] as? String {
          resultDecodedBuilder.severity = Int32(jsonValueSeverity)!
        }
        if let jsonValueFromSegmentId = jsonMap["fromSegmentId"] as? Int {
          resultDecodedBuilder.fromSegmentId = Int32(jsonValueFromSegmentId)
        } else if let jsonValueFromSegmentId = jsonMap["fromSegmentId"] as? String {
          resultDecodedBuilder.fromSegmentId = Int32(jsonValueFromSegmentId)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantLosEventPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantLosEventPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantLodPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantLodPb, rhs: Duel.Pta.Api.PtaassistantLodPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.losEventlist == rhs.losEventlist)
      fieldCheck = fieldCheck && (lhs.hasSingleIntro == rhs.hasSingleIntro) && (!lhs.hasSingleIntro || lhs.singleIntro == rhs.singleIntro)
      fieldCheck = fieldCheck && (lhs.hasCompleteIntro == rhs.hasCompleteIntro) && (!lhs.hasCompleteIntro || lhs.completeIntro == rhs.completeIntro)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var losEventlist:Array<Duel.Pta.Api.PtaassistantLoslistPb>  = Array<Duel.Pta.Api.PtaassistantLoslistPb>()
    //preambolo della singola traiettoria(per bollettivo della sola traiettoria)
    public fileprivate(set) var singleIntro:String = ""
    public fileprivate(set) var hasSingleIntro:Bool = false

    //preambolo della singola traiettoria con connettivi(per bollettino completo)
    public fileprivate(set) var completeIntro:String = ""
    public fileprivate(set) var hasCompleteIntro:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementLosEventlist in losEventlist {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementLosEventlist)
      }
      if hasSingleIntro {
        try codedOutputStream.writeString(fieldNumber: 2, value:singleIntro)
      }
      if hasCompleteIntro {
        try codedOutputStream.writeString(fieldNumber: 3, value:completeIntro)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementLosEventlist in losEventlist {
          serialize_size += oneElementLosEventlist.computeMessageSize(fieldNumber: 1)
      }
      if hasSingleIntro {
        serialize_size += singleIntro.computeStringSize(fieldNumber: 2)
      }
      if hasCompleteIntro {
        serialize_size += completeIntro.computeStringSize(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantLodPb.Builder {
      return Duel.Pta.Api.PtaassistantLodPb.classBuilder() as! Duel.Pta.Api.PtaassistantLodPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantLodPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantLodPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLodPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLodPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
      return try Duel.Pta.Api.PtaassistantLodPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantLodPb) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
      return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !losEventlist.isEmpty {
        var jsonArrayLosEventlist:Array<Dictionary<String,Any>> = []
          for oneValueLosEventlist in losEventlist {
            let ecodedMessageLosEventlist = try oneValueLosEventlist.encode()
            jsonArrayLosEventlist.append(ecodedMessageLosEventlist)
          }
        jsonMap["losEventlist"] = jsonArrayLosEventlist
      }
      if hasSingleIntro {
        jsonMap["singleIntro"] = singleIntro
      }
      if hasCompleteIntro {
        jsonMap["completeIntro"] = completeIntro
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLodPb {
      return try Duel.Pta.Api.PtaassistantLodPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantLodPb {
      return try Duel.Pta.Api.PtaassistantLodPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var losEventlistElementIndex:Int = 0
      for oneElementLosEventlist in losEventlist {
          output += "\(indent) losEventlist[\(losEventlistElementIndex)] {\n"
          output += try oneElementLosEventlist.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          losEventlistElementIndex += 1
      }
      if hasSingleIntro {
        output += "\(indent) singleIntro: \(singleIntro) \n"
      }
      if hasCompleteIntro {
        output += "\(indent) completeIntro: \(completeIntro) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementLosEventlist in losEventlist {
                hashCode = (hashCode &* 31) &+ oneElementLosEventlist.hashValue
            }
            if hasSingleIntro {
               hashCode = (hashCode &* 31) &+ singleIntro.hashValue
            }
            if hasCompleteIntro {
               hashCode = (hashCode &* 31) &+ completeIntro.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantLodPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantLodPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantLodPb = Duel.Pta.Api.PtaassistantLodPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantLodPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var losEventlist:Array<Duel.Pta.Api.PtaassistantLoslistPb> {
           get {
               return builderResult.losEventlist
           }
           set (value) {
               builderResult.losEventlist = value
           }
      }
      @discardableResult
      public func setLosEventlist(_ value:Array<Duel.Pta.Api.PtaassistantLoslistPb>) -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        self.losEventlist = value
        return self
      }
      @discardableResult
      public func clearLosEventlist() -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        builderResult.losEventlist.removeAll(keepingCapacity: false)
        return self
      }
      public var hasSingleIntro:Bool {
           get {
                return builderResult.hasSingleIntro
           }
      }
      public var singleIntro:String {
           get {
                return builderResult.singleIntro
           }
           set (value) {
               builderResult.hasSingleIntro = true
               builderResult.singleIntro = value
           }
      }
      @discardableResult
      public func setSingleIntro(_ value:String) -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        self.singleIntro = value
        return self
      }
      @discardableResult
      public func clearSingleIntro() -> Duel.Pta.Api.PtaassistantLodPb.Builder{
           builderResult.hasSingleIntro = false
           builderResult.singleIntro = ""
           return self
      }
      public var hasCompleteIntro:Bool {
           get {
                return builderResult.hasCompleteIntro
           }
      }
      public var completeIntro:String {
           get {
                return builderResult.completeIntro
           }
           set (value) {
               builderResult.hasCompleteIntro = true
               builderResult.completeIntro = value
           }
      }
      @discardableResult
      public func setCompleteIntro(_ value:String) -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        self.completeIntro = value
        return self
      }
      @discardableResult
      public func clearCompleteIntro() -> Duel.Pta.Api.PtaassistantLodPb.Builder{
           builderResult.hasCompleteIntro = false
           builderResult.completeIntro = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantLodPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        return try Duel.Pta.Api.PtaassistantLodPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantLodPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantLodPb {
        let returnMe:Duel.Pta.Api.PtaassistantLodPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantLodPb) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        if other == Duel.Pta.Api.PtaassistantLodPb() {
         return self
        }
        if !other.losEventlist.isEmpty  {
           builderResult.losEventlist += other.losEventlist
        }
        if other.hasSingleIntro {
             singleIntro = other.singleIntro
        }
        if other.hasCompleteIntro {
             completeIntro = other.completeIntro
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Duel.Pta.Api.PtaassistantLoslistPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            losEventlist.append(subBuilder.buildPartial())

          case 18:
            singleIntro = try codedInputStream.readString()

          case 26:
            completeIntro = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantLodPb.Builder()
        if let jsonValueLosEventlist = jsonMap["losEventlist"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLosEventlist:Array<Duel.Pta.Api.PtaassistantLoslistPb> = []
          for oneValueLosEventlist in jsonValueLosEventlist {
            let messageFromStringLosEventlist = try Duel.Pta.Api.PtaassistantLoslistPb.Builder.decodeToBuilder(jsonMap:oneValueLosEventlist).build()

            jsonArrayLosEventlist.append(messageFromStringLosEventlist)
          }
          resultDecodedBuilder.losEventlist = jsonArrayLosEventlist
        }
        if let jsonValueSingleIntro = jsonMap["singleIntro"] as? String {
          resultDecodedBuilder.singleIntro = jsonValueSingleIntro
        }
        if let jsonValueCompleteIntro = jsonMap["completeIntro"] as? String {
          resultDecodedBuilder.completeIntro = jsonValueCompleteIntro
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantLodPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantLodPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantLoslistPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantLoslistPb, rhs: Duel.Pta.Api.PtaassistantLoslistPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.losEventIds == rhs.losEventIds)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    //lista id eventi di traffico
    public fileprivate(set) var losEventIds:Array<Int32> = Array<Int32>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if !losEventIds.isEmpty {
        for oneValuelosEventIds in losEventIds {
          try codedOutputStream.writeInt32(fieldNumber: 1, value:oneValuelosEventIds)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizeLosEventIds:Int32 = 0
      for oneValuelosEventIds in losEventIds {
          dataSizeLosEventIds += oneValuelosEventIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeLosEventIds
      serialize_size += 1 * Int32(losEventIds.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
      return Duel.Pta.Api.PtaassistantLoslistPb.classBuilder() as! Duel.Pta.Api.PtaassistantLoslistPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantLoslistPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLoslistPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantLoslistPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
      return try Duel.Pta.Api.PtaassistantLoslistPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantLoslistPb) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
      return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !losEventIds.isEmpty {
        var jsonArrayLosEventIds:Array<Int> = []
          for oneValueLosEventIds in losEventIds {
            jsonArrayLosEventIds.append(Int(oneValueLosEventIds))
          }
        jsonMap["losEventIds"] = jsonArrayLosEventIds
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
      return try Duel.Pta.Api.PtaassistantLoslistPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
      return try Duel.Pta.Api.PtaassistantLoslistPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var losEventIdsElementIndex:Int = 0
      for oneValueLosEventIds in losEventIds  {
          output += "\(indent) losEventIds[\(losEventIdsElementIndex)]: \(oneValueLosEventIds)\n"
          losEventIdsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueLosEventIds in losEventIds {
                hashCode = (hashCode &* 31) &+ oneValueLosEventIds.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantLoslistPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantLoslistPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantLoslistPb = Duel.Pta.Api.PtaassistantLoslistPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantLoslistPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var losEventIds:Array<Int32> {
           get {
               return builderResult.losEventIds
           }
           set (array) {
               builderResult.losEventIds = array
           }
      }
      @discardableResult
      public func setLosEventIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        self.losEventIds = value
        return self
      }
      @discardableResult
      public func clearLosEventIds() -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
         builderResult.losEventIds.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantLoslistPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        return try Duel.Pta.Api.PtaassistantLoslistPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantLoslistPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantLoslistPb {
        let returnMe:Duel.Pta.Api.PtaassistantLoslistPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantLoslistPb) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        if other == Duel.Pta.Api.PtaassistantLoslistPb() {
         return self
        }
        if !other.losEventIds.isEmpty {
            builderResult.losEventIds += other.losEventIds
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            losEventIds += [try codedInputStream.readInt32()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantLoslistPb.Builder()
        if let jsonValueLosEventIds = jsonMap["losEventIds"] as? Array<Int> {
          var jsonArrayLosEventIds:Array<Int32> = []
          for oneValueLosEventIds in jsonValueLosEventIds {
            jsonArrayLosEventIds.append(Int32(oneValueLosEventIds))
          }
          resultDecodedBuilder.losEventIds = jsonArrayLosEventIds
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantLoslistPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantLoslistPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantPathPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantPathPb, rhs: Duel.Pta.Api.PtaassistantPathPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasPathId == rhs.hasPathId) && (!lhs.hasPathId || lhs.pathId == rhs.pathId)
      fieldCheck = fieldCheck && (lhs.segmentIds == rhs.segmentIds)
      fieldCheck = fieldCheck && (lhs.hasArrivalTime == rhs.hasArrivalTime) && (!lhs.hasArrivalTime || lhs.arrivalTime == rhs.arrivalTime)
      fieldCheck = fieldCheck && (lhs.hasLength == rhs.hasLength) && (!lhs.hasLength || lhs.length == rhs.length)
      fieldCheck = fieldCheck && (lhs.roadNames == rhs.roadNames)
      fieldCheck = fieldCheck && (lhs.lod == rhs.lod)
      fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var pathId:Int32 = Int32(0)
    public fileprivate(set) var hasPathId:Bool = false

    //lista id segmenti della traiettoria
    public fileprivate(set) var segmentIds:Array<Int32> = Array<Int32>()
    //tempo stimato di arrivo
    public fileprivate(set) var arrivalTime:Int64 = Int64(0)
    public fileprivate(set) var hasArrivalTime:Bool = false

    //lunghezza della traiettoria
    public fileprivate(set) var length:Float = Float(0)
    public fileprivate(set) var hasLength:Bool = false

    //lista strade principali
    public fileprivate(set) var roadNames:Array<String> = Array<String>()
    public fileprivate(set) var lod:Array<Duel.Pta.Api.PtaassistantLodPb>  = Array<Duel.Pta.Api.PtaassistantLodPb>()
    public fileprivate(set) var type:Duel.Pta.Api.PtapathType = Duel.Pta.Api.PtapathType.typical
    public fileprivate(set) var hasType:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasPathId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:pathId)
      }
      if !segmentIds.isEmpty {
        for oneValuesegmentIds in segmentIds {
          try codedOutputStream.writeInt32(fieldNumber: 2, value:oneValuesegmentIds)
        }
      }
      if hasArrivalTime {
        try codedOutputStream.writeInt64(fieldNumber: 3, value:arrivalTime)
      }
      if hasLength {
        try codedOutputStream.writeFloat(fieldNumber: 4, value:length)
      }
      if !roadNames.isEmpty {
        for oneValueroadNames in roadNames {
          try codedOutputStream.writeString(fieldNumber: 5, value:oneValueroadNames)
        }
      }
      for oneElementLod in lod {
          try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementLod)
      }
      if hasType {
        try codedOutputStream.writeEnum(fieldNumber: 7, value:type.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasPathId {
        serialize_size += pathId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizeSegmentIds:Int32 = 0
      for oneValuesegmentIds in segmentIds {
          dataSizeSegmentIds += oneValuesegmentIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeSegmentIds
      serialize_size += 1 * Int32(segmentIds.count)
      if hasArrivalTime {
        serialize_size += arrivalTime.computeInt64Size(fieldNumber: 3)
      }
      if hasLength {
        serialize_size += length.computeFloatSize(fieldNumber: 4)
      }
      var dataSizeRoadNames:Int32 = 0
      for oneValueroadNames in roadNames {
          dataSizeRoadNames += oneValueroadNames.computeStringSizeNoTag()
      }
      serialize_size += dataSizeRoadNames
      serialize_size += 1 * Int32(roadNames.count)
      for oneElementLod in lod {
          serialize_size += oneElementLod.computeMessageSize(fieldNumber: 6)
      }
      if (hasType) {
        serialize_size += type.rawValue.computeEnumSize(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
      return Duel.Pta.Api.PtaassistantPathPb.classBuilder() as! Duel.Pta.Api.PtaassistantPathPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantPathPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantPathPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantPathPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
      return try Duel.Pta.Api.PtaassistantPathPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantPathPb) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
      return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasPathId {
        jsonMap["pathId"] = Int(pathId)
      }
      if !segmentIds.isEmpty {
        var jsonArraySegmentIds:Array<Int> = []
          for oneValueSegmentIds in segmentIds {
            jsonArraySegmentIds.append(Int(oneValueSegmentIds))
          }
        jsonMap["segmentIds"] = jsonArraySegmentIds
      }
      if hasArrivalTime {
        jsonMap["arrivalTime"] = "\(arrivalTime)"
      }
      if hasLength {
        jsonMap["length"] = Float(length)
      }
      if !roadNames.isEmpty {
        var jsonArrayRoadNames:Array<String> = []
          for oneValueRoadNames in roadNames {
            jsonArrayRoadNames.append(oneValueRoadNames)
          }
        jsonMap["roadNames"] = jsonArrayRoadNames
      }
      if !lod.isEmpty {
        var jsonArrayLod:Array<Dictionary<String,Any>> = []
          for oneValueLod in lod {
            let ecodedMessageLod = try oneValueLod.encode()
            jsonArrayLod.append(ecodedMessageLod)
          }
        jsonMap["lod"] = jsonArrayLod
      }
      if hasType {
        jsonMap["type"] = type.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantPathPb {
      return try Duel.Pta.Api.PtaassistantPathPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantPathPb {
      return try Duel.Pta.Api.PtaassistantPathPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasPathId {
        output += "\(indent) pathId: \(pathId) \n"
      }
      var segmentIdsElementIndex:Int = 0
      for oneValueSegmentIds in segmentIds  {
          output += "\(indent) segmentIds[\(segmentIdsElementIndex)]: \(oneValueSegmentIds)\n"
          segmentIdsElementIndex += 1
      }
      if hasArrivalTime {
        output += "\(indent) arrivalTime: \(arrivalTime) \n"
      }
      if hasLength {
        output += "\(indent) length: \(length) \n"
      }
      var roadNamesElementIndex:Int = 0
      for oneValueRoadNames in roadNames  {
          output += "\(indent) roadNames[\(roadNamesElementIndex)]: \(oneValueRoadNames)\n"
          roadNamesElementIndex += 1
      }
      var lodElementIndex:Int = 0
      for oneElementLod in lod {
          output += "\(indent) lod[\(lodElementIndex)] {\n"
          output += try oneElementLod.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          lodElementIndex += 1
      }
      if (hasType) {
        output += "\(indent) type: \(type.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPathId {
               hashCode = (hashCode &* 31) &+ pathId.hashValue
            }
            for oneValueSegmentIds in segmentIds {
                hashCode = (hashCode &* 31) &+ oneValueSegmentIds.hashValue
            }
            if hasArrivalTime {
               hashCode = (hashCode &* 31) &+ arrivalTime.hashValue
            }
            if hasLength {
               hashCode = (hashCode &* 31) &+ length.hashValue
            }
            for oneValueRoadNames in roadNames {
                hashCode = (hashCode &* 31) &+ oneValueRoadNames.hashValue
            }
            for oneElementLod in lod {
                hashCode = (hashCode &* 31) &+ oneElementLod.hashValue
            }
            if hasType {
               hashCode = (hashCode &* 31) &+ Int(type.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantPathPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantPathPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantPathPb = Duel.Pta.Api.PtaassistantPathPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantPathPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasPathId:Bool {
           get {
                return builderResult.hasPathId
           }
      }
      public var pathId:Int32 {
           get {
                return builderResult.pathId
           }
           set (value) {
               builderResult.hasPathId = true
               builderResult.pathId = value
           }
      }
      @discardableResult
      public func setPathId(_ value:Int32) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.pathId = value
        return self
      }
      @discardableResult
      public func clearPathId() -> Duel.Pta.Api.PtaassistantPathPb.Builder{
           builderResult.hasPathId = false
           builderResult.pathId = Int32(0)
           return self
      }
      public var segmentIds:Array<Int32> {
           get {
               return builderResult.segmentIds
           }
           set (array) {
               builderResult.segmentIds = array
           }
      }
      @discardableResult
      public func setSegmentIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.segmentIds = value
        return self
      }
      @discardableResult
      public func clearSegmentIds() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
         builderResult.segmentIds.removeAll(keepingCapacity: false)
         return self
      }
      public var hasArrivalTime:Bool {
           get {
                return builderResult.hasArrivalTime
           }
      }
      public var arrivalTime:Int64 {
           get {
                return builderResult.arrivalTime
           }
           set (value) {
               builderResult.hasArrivalTime = true
               builderResult.arrivalTime = value
           }
      }
      @discardableResult
      public func setArrivalTime(_ value:Int64) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.arrivalTime = value
        return self
      }
      @discardableResult
      public func clearArrivalTime() -> Duel.Pta.Api.PtaassistantPathPb.Builder{
           builderResult.hasArrivalTime = false
           builderResult.arrivalTime = Int64(0)
           return self
      }
      public var hasLength:Bool {
           get {
                return builderResult.hasLength
           }
      }
      public var length:Float {
           get {
                return builderResult.length
           }
           set (value) {
               builderResult.hasLength = true
               builderResult.length = value
           }
      }
      @discardableResult
      public func setLength(_ value:Float) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.length = value
        return self
      }
      @discardableResult
      public func clearLength() -> Duel.Pta.Api.PtaassistantPathPb.Builder{
           builderResult.hasLength = false
           builderResult.length = Float(0)
           return self
      }
      public var roadNames:Array<String> {
           get {
               return builderResult.roadNames
           }
           set (array) {
               builderResult.roadNames = array
           }
      }
      @discardableResult
      public func setRoadNames(_ value:Array<String>) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.roadNames = value
        return self
      }
      @discardableResult
      public func clearRoadNames() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
         builderResult.roadNames.removeAll(keepingCapacity: false)
         return self
      }
      public var lod:Array<Duel.Pta.Api.PtaassistantLodPb> {
           get {
               return builderResult.lod
           }
           set (value) {
               builderResult.lod = value
           }
      }
      @discardableResult
      public func setLod(_ value:Array<Duel.Pta.Api.PtaassistantLodPb>) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        self.lod = value
        return self
      }
      @discardableResult
      public func clearLod() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        builderResult.lod.removeAll(keepingCapacity: false)
        return self
      }
        public var hasType:Bool{
            get {
                return builderResult.hasType
            }
        }
        public var type:Duel.Pta.Api.PtapathType {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
      @discardableResult
        public func setType(_ value:Duel.Pta.Api.PtapathType) -> Duel.Pta.Api.PtaassistantPathPb.Builder {
          self.type = value
          return self
        }
      @discardableResult
        public func clearType() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
           builderResult.hasType = false
           builderResult.type = .typical
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantPathPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        return try Duel.Pta.Api.PtaassistantPathPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantPathPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantPathPb {
        let returnMe:Duel.Pta.Api.PtaassistantPathPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantPathPb) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        if other == Duel.Pta.Api.PtaassistantPathPb() {
         return self
        }
        if other.hasPathId {
             pathId = other.pathId
        }
        if !other.segmentIds.isEmpty {
            builderResult.segmentIds += other.segmentIds
        }
        if other.hasArrivalTime {
             arrivalTime = other.arrivalTime
        }
        if other.hasLength {
             length = other.length
        }
        if !other.roadNames.isEmpty {
            builderResult.roadNames += other.roadNames
        }
        if !other.lod.isEmpty  {
           builderResult.lod += other.lod
        }
        if other.hasType {
             type = other.type
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            pathId = try codedInputStream.readInt32()

          case 16:
            segmentIds += [try codedInputStream.readInt32()]

          case 24:
            arrivalTime = try codedInputStream.readInt64()

          case 37:
            length = try codedInputStream.readFloat()

          case 42:
            roadNames += [try codedInputStream.readString()]

          case 50:
            let subBuilder = Duel.Pta.Api.PtaassistantLodPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            lod.append(subBuilder.buildPartial())

          case 56:
            let valueInttype = try codedInputStream.readEnum()
            if let enumstype = Duel.Pta.Api.PtapathType(rawValue:valueInttype){
                 type = enumstype
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueInttype))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantPathPb.Builder()
        if let jsonValuePathId = jsonMap["pathId"] as? Int {
          resultDecodedBuilder.pathId = Int32(jsonValuePathId)
        } else if let jsonValuePathId = jsonMap["pathId"] as? String {
          resultDecodedBuilder.pathId = Int32(jsonValuePathId)!
        }
        if let jsonValueSegmentIds = jsonMap["segmentIds"] as? Array<Int> {
          var jsonArraySegmentIds:Array<Int32> = []
          for oneValueSegmentIds in jsonValueSegmentIds {
            jsonArraySegmentIds.append(Int32(oneValueSegmentIds))
          }
          resultDecodedBuilder.segmentIds = jsonArraySegmentIds
        }
        if let jsonValueArrivalTime = jsonMap["arrivalTime"] as? String {
          resultDecodedBuilder.arrivalTime = Int64(jsonValueArrivalTime)!
        } else if let jsonValueArrivalTime = jsonMap["arrivalTime"] as? Int {
          resultDecodedBuilder.arrivalTime = Int64(jsonValueArrivalTime)
        }
        if let jsonValueLength = jsonMap["length"] as? Float {
          resultDecodedBuilder.length = Float(jsonValueLength)
        } else if let jsonValueLength = jsonMap["length"] as? String {
          resultDecodedBuilder.length = Float(jsonValueLength)!
        }
        if let jsonValueRoadNames = jsonMap["roadNames"] as? Array<String> {
          var jsonArrayRoadNames:Array<String> = []
          for oneValueRoadNames in jsonValueRoadNames {
            jsonArrayRoadNames.append(oneValueRoadNames)
          }
          resultDecodedBuilder.roadNames = jsonArrayRoadNames
        }
        if let jsonValueLod = jsonMap["lod"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLod:Array<Duel.Pta.Api.PtaassistantLodPb> = []
          for oneValueLod in jsonValueLod {
            let messageFromStringLod = try Duel.Pta.Api.PtaassistantLodPb.Builder.decodeToBuilder(jsonMap:oneValueLod).build()

            jsonArrayLod.append(messageFromStringLod)
          }
          resultDecodedBuilder.lod = jsonArrayLod
        }
        if let jsonValueType = jsonMap["type"] as? String {
          resultDecodedBuilder.type = try Duel.Pta.Api.PtapathType.fromString(str: jsonValueType)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantPathPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantPathPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantUseCasePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantUseCasePb, rhs: Duel.Pta.Api.PtaassistantUseCasePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.usecaseId == rhs.usecaseId)
      fieldCheck = fieldCheck && (lhs.usecaseName == rhs.usecaseName)
      fieldCheck = fieldCheck && (lhs.usecaseDesc == rhs.usecaseDesc)
      fieldCheck = fieldCheck && (lhs.hasUsecase == rhs.hasUsecase) && (!lhs.hasUsecase || lhs.usecase == rhs.usecase)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var usecaseId:Array<Int32> = Array<Int32>()
    public fileprivate(set) var usecaseName:Array<String> = Array<String>()
    public fileprivate(set) var usecaseDesc:Array<String> = Array<String>()
    public fileprivate(set) var usecase:Duel.Pta.Api.PtaassistantResponsePb!
    public fileprivate(set) var hasUsecase:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if !usecaseId.isEmpty {
        for oneValueusecaseId in usecaseId {
          try codedOutputStream.writeInt32(fieldNumber: 1, value:oneValueusecaseId)
        }
      }
      if !usecaseName.isEmpty {
        for oneValueusecaseName in usecaseName {
          try codedOutputStream.writeString(fieldNumber: 2, value:oneValueusecaseName)
        }
      }
      if !usecaseDesc.isEmpty {
        for oneValueusecaseDesc in usecaseDesc {
          try codedOutputStream.writeString(fieldNumber: 3, value:oneValueusecaseDesc)
        }
      }
      if hasUsecase {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:usecase)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizeUsecaseId:Int32 = 0
      for oneValueusecaseId in usecaseId {
          dataSizeUsecaseId += oneValueusecaseId.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeUsecaseId
      serialize_size += 1 * Int32(usecaseId.count)
      var dataSizeUsecaseName:Int32 = 0
      for oneValueusecaseName in usecaseName {
          dataSizeUsecaseName += oneValueusecaseName.computeStringSizeNoTag()
      }
      serialize_size += dataSizeUsecaseName
      serialize_size += 1 * Int32(usecaseName.count)
      var dataSizeUsecaseDesc:Int32 = 0
      for oneValueusecaseDesc in usecaseDesc {
          dataSizeUsecaseDesc += oneValueusecaseDesc.computeStringSizeNoTag()
      }
      serialize_size += dataSizeUsecaseDesc
      serialize_size += 1 * Int32(usecaseDesc.count)
      if hasUsecase {
          if let varSizeusecase = usecase?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizeusecase
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
      return Duel.Pta.Api.PtaassistantUseCasePb.classBuilder() as! Duel.Pta.Api.PtaassistantUseCasePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantUseCasePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantUseCasePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantUseCasePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
      return try Duel.Pta.Api.PtaassistantUseCasePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantUseCasePb) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
      return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !usecaseId.isEmpty {
        var jsonArrayUsecaseId:Array<Int> = []
          for oneValueUsecaseId in usecaseId {
            jsonArrayUsecaseId.append(Int(oneValueUsecaseId))
          }
        jsonMap["usecaseId"] = jsonArrayUsecaseId
      }
      if !usecaseName.isEmpty {
        var jsonArrayUsecaseName:Array<String> = []
          for oneValueUsecaseName in usecaseName {
            jsonArrayUsecaseName.append(oneValueUsecaseName)
          }
        jsonMap["usecaseName"] = jsonArrayUsecaseName
      }
      if !usecaseDesc.isEmpty {
        var jsonArrayUsecaseDesc:Array<String> = []
          for oneValueUsecaseDesc in usecaseDesc {
            jsonArrayUsecaseDesc.append(oneValueUsecaseDesc)
          }
        jsonMap["usecaseDesc"] = jsonArrayUsecaseDesc
      }
      if hasUsecase {
        jsonMap["usecase"] = try usecase.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
      return try Duel.Pta.Api.PtaassistantUseCasePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
      return try Duel.Pta.Api.PtaassistantUseCasePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var usecaseIdElementIndex:Int = 0
      for oneValueUsecaseId in usecaseId  {
          output += "\(indent) usecaseId[\(usecaseIdElementIndex)]: \(oneValueUsecaseId)\n"
          usecaseIdElementIndex += 1
      }
      var usecaseNameElementIndex:Int = 0
      for oneValueUsecaseName in usecaseName  {
          output += "\(indent) usecaseName[\(usecaseNameElementIndex)]: \(oneValueUsecaseName)\n"
          usecaseNameElementIndex += 1
      }
      var usecaseDescElementIndex:Int = 0
      for oneValueUsecaseDesc in usecaseDesc  {
          output += "\(indent) usecaseDesc[\(usecaseDescElementIndex)]: \(oneValueUsecaseDesc)\n"
          usecaseDescElementIndex += 1
      }
      if hasUsecase {
        output += "\(indent) usecase {\n"
        if let outDescUsecase = usecase {
          output += try outDescUsecase.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueUsecaseId in usecaseId {
                hashCode = (hashCode &* 31) &+ oneValueUsecaseId.hashValue
            }
            for oneValueUsecaseName in usecaseName {
                hashCode = (hashCode &* 31) &+ oneValueUsecaseName.hashValue
            }
            for oneValueUsecaseDesc in usecaseDesc {
                hashCode = (hashCode &* 31) &+ oneValueUsecaseDesc.hashValue
            }
            if hasUsecase {
                if let hashValueusecase = usecase?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueusecase
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantUseCasePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantUseCasePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantUseCasePb = Duel.Pta.Api.PtaassistantUseCasePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantUseCasePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var usecaseId:Array<Int32> {
           get {
               return builderResult.usecaseId
           }
           set (array) {
               builderResult.usecaseId = array
           }
      }
      @discardableResult
      public func setUsecaseId(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        self.usecaseId = value
        return self
      }
      @discardableResult
      public func clearUsecaseId() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
         builderResult.usecaseId.removeAll(keepingCapacity: false)
         return self
      }
      public var usecaseName:Array<String> {
           get {
               return builderResult.usecaseName
           }
           set (array) {
               builderResult.usecaseName = array
           }
      }
      @discardableResult
      public func setUsecaseName(_ value:Array<String>) -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        self.usecaseName = value
        return self
      }
      @discardableResult
      public func clearUsecaseName() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
         builderResult.usecaseName.removeAll(keepingCapacity: false)
         return self
      }
      public var usecaseDesc:Array<String> {
           get {
               return builderResult.usecaseDesc
           }
           set (array) {
               builderResult.usecaseDesc = array
           }
      }
      @discardableResult
      public func setUsecaseDesc(_ value:Array<String>) -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        self.usecaseDesc = value
        return self
      }
      @discardableResult
      public func clearUsecaseDesc() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
         builderResult.usecaseDesc.removeAll(keepingCapacity: false)
         return self
      }
      public var hasUsecase:Bool {
           get {
               return builderResult.hasUsecase
           }
      }
      public var usecase:Duel.Pta.Api.PtaassistantResponsePb! {
           get {
               if usecaseBuilder_ != nil {
                  builderResult.usecase = usecaseBuilder_.getMessage()
               }
               return builderResult.usecase
           }
           set (value) {
               builderResult.hasUsecase = true
               builderResult.usecase = value
           }
      }
      fileprivate var usecaseBuilder_:Duel.Pta.Api.PtaassistantResponsePb.Builder! {
           didSet {
              builderResult.hasUsecase = true
           }
      }
      public func getUsecaseBuilder() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        if usecaseBuilder_ == nil {
           usecaseBuilder_ = Duel.Pta.Api.PtaassistantResponsePb.Builder()
           builderResult.usecase = usecaseBuilder_.getMessage()
           if usecase != nil {
              try! usecaseBuilder_.mergeFrom(other: usecase)
           }
        }
        return usecaseBuilder_
      }
      @discardableResult
      public func setUsecase(_ value:Duel.Pta.Api.PtaassistantResponsePb!) -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        self.usecase = value
        return self
      }
      @discardableResult
      public func mergeUsecase(value:Duel.Pta.Api.PtaassistantResponsePb) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        if builderResult.hasUsecase {
          builderResult.usecase = try Duel.Pta.Api.PtaassistantResponsePb.builderWithPrototype(prototype:builderResult.usecase).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.usecase = value
        }
        builderResult.hasUsecase = true
        return self
      }
      @discardableResult
      public func clearUsecase() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        usecaseBuilder_ = nil
        builderResult.hasUsecase = false
        builderResult.usecase = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantUseCasePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        return try Duel.Pta.Api.PtaassistantUseCasePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantUseCasePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantUseCasePb {
        let returnMe:Duel.Pta.Api.PtaassistantUseCasePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantUseCasePb) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        if other == Duel.Pta.Api.PtaassistantUseCasePb() {
         return self
        }
        if !other.usecaseId.isEmpty {
            builderResult.usecaseId += other.usecaseId
        }
        if !other.usecaseName.isEmpty {
            builderResult.usecaseName += other.usecaseName
        }
        if !other.usecaseDesc.isEmpty {
            builderResult.usecaseDesc += other.usecaseDesc
        }
        if (other.hasUsecase) {
            try mergeUsecase(value: other.usecase)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            usecaseId += [try codedInputStream.readInt32()]

          case 18:
            usecaseName += [try codedInputStream.readString()]

          case 26:
            usecaseDesc += [try codedInputStream.readString()]

          case 34:
            let subBuilder:Duel.Pta.Api.PtaassistantResponsePb.Builder = Duel.Pta.Api.PtaassistantResponsePb.Builder()
            if hasUsecase {
              try subBuilder.mergeFrom(other: usecase)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            usecase = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantUseCasePb.Builder()
        if let jsonValueUsecaseId = jsonMap["usecaseId"] as? Array<Int> {
          var jsonArrayUsecaseId:Array<Int32> = []
          for oneValueUsecaseId in jsonValueUsecaseId {
            jsonArrayUsecaseId.append(Int32(oneValueUsecaseId))
          }
          resultDecodedBuilder.usecaseId = jsonArrayUsecaseId
        }
        if let jsonValueUsecaseName = jsonMap["usecaseName"] as? Array<String> {
          var jsonArrayUsecaseName:Array<String> = []
          for oneValueUsecaseName in jsonValueUsecaseName {
            jsonArrayUsecaseName.append(oneValueUsecaseName)
          }
          resultDecodedBuilder.usecaseName = jsonArrayUsecaseName
        }
        if let jsonValueUsecaseDesc = jsonMap["usecaseDesc"] as? Array<String> {
          var jsonArrayUsecaseDesc:Array<String> = []
          for oneValueUsecaseDesc in jsonValueUsecaseDesc {
            jsonArrayUsecaseDesc.append(oneValueUsecaseDesc)
          }
          resultDecodedBuilder.usecaseDesc = jsonArrayUsecaseDesc
        }
        if let jsonValueUsecase = jsonMap["usecase"] as? Dictionary<String,Any> {
          resultDecodedBuilder.usecase = try Duel.Pta.Api.PtaassistantResponsePb.Builder.decodeToBuilder(jsonMap:jsonValueUsecase).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantUseCasePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantUseCasePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoRequestPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoRequestPb, rhs: Duel.Pta.Api.PtaassistantDemoRequestPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasRequestId == rhs.hasRequestId) && (!lhs.hasRequestId || lhs.requestId == rhs.requestId)
      fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
      fieldCheck = fieldCheck && (lhs.trajectory == rhs.trajectory)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var requestId:Int32 = Int32(0)
    public fileprivate(set) var hasRequestId:Bool = false

    public fileprivate(set) var data:Duel.Pta.Api.PtaassistantResponsePb!
    public fileprivate(set) var hasData:Bool = false
    public fileprivate(set) var trajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb>  = Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasRequestId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:requestId)
      }
      if hasData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:data)
      }
      for oneElementTrajectory in trajectory {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementTrajectory)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasRequestId {
        serialize_size += requestId.computeInt32Size(fieldNumber: 1)
      }
      if hasData {
          if let varSizedata = data?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizedata
          }
      }
      for oneElementTrajectory in trajectory {
          serialize_size += oneElementTrajectory.computeMessageSize(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
      return Duel.Pta.Api.PtaassistantDemoRequestPb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoRequestPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoRequestPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoRequestPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoRequestPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoRequestPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoRequestPb) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasRequestId {
        jsonMap["requestId"] = Int(requestId)
      }
      if hasData {
        jsonMap["data"] = try data.encode()
      }
      if !trajectory.isEmpty {
        var jsonArrayTrajectory:Array<Dictionary<String,Any>> = []
          for oneValueTrajectory in trajectory {
            let ecodedMessageTrajectory = try oneValueTrajectory.encode()
            jsonArrayTrajectory.append(ecodedMessageTrajectory)
          }
        jsonMap["trajectory"] = jsonArrayTrajectory
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
      return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
      return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasRequestId {
        output += "\(indent) requestId: \(requestId) \n"
      }
      if hasData {
        output += "\(indent) data {\n"
        if let outDescData = data {
          output += try outDescData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var trajectoryElementIndex:Int = 0
      for oneElementTrajectory in trajectory {
          output += "\(indent) trajectory[\(trajectoryElementIndex)] {\n"
          output += try oneElementTrajectory.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          trajectoryElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasRequestId {
               hashCode = (hashCode &* 31) &+ requestId.hashValue
            }
            if hasData {
                if let hashValuedata = data?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuedata
                }
            }
            for oneElementTrajectory in trajectory {
                hashCode = (hashCode &* 31) &+ oneElementTrajectory.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoRequestPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoRequestPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoRequestPb = Duel.Pta.Api.PtaassistantDemoRequestPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoRequestPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasRequestId:Bool {
           get {
                return builderResult.hasRequestId
           }
      }
      public var requestId:Int32 {
           get {
                return builderResult.requestId
           }
           set (value) {
               builderResult.hasRequestId = true
               builderResult.requestId = value
           }
      }
      @discardableResult
      public func setRequestId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        self.requestId = value
        return self
      }
      @discardableResult
      public func clearRequestId() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder{
           builderResult.hasRequestId = false
           builderResult.requestId = Int32(0)
           return self
      }
      public var hasData:Bool {
           get {
               return builderResult.hasData
           }
      }
      public var data:Duel.Pta.Api.PtaassistantResponsePb! {
           get {
               if dataBuilder_ != nil {
                  builderResult.data = dataBuilder_.getMessage()
               }
               return builderResult.data
           }
           set (value) {
               builderResult.hasData = true
               builderResult.data = value
           }
      }
      fileprivate var dataBuilder_:Duel.Pta.Api.PtaassistantResponsePb.Builder! {
           didSet {
              builderResult.hasData = true
           }
      }
      public func getDataBuilder() -> Duel.Pta.Api.PtaassistantResponsePb.Builder {
        if dataBuilder_ == nil {
           dataBuilder_ = Duel.Pta.Api.PtaassistantResponsePb.Builder()
           builderResult.data = dataBuilder_.getMessage()
           if data != nil {
              try! dataBuilder_.mergeFrom(other: data)
           }
        }
        return dataBuilder_
      }
      @discardableResult
      public func setData(_ value:Duel.Pta.Api.PtaassistantResponsePb!) -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        self.data = value
        return self
      }
      @discardableResult
      public func mergeData(value:Duel.Pta.Api.PtaassistantResponsePb) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        if builderResult.hasData {
          builderResult.data = try Duel.Pta.Api.PtaassistantResponsePb.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.data = value
        }
        builderResult.hasData = true
        return self
      }
      @discardableResult
      public func clearData() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        dataBuilder_ = nil
        builderResult.hasData = false
        builderResult.data = nil
        return self
      }
      public var trajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb> {
           get {
               return builderResult.trajectory
           }
           set (value) {
               builderResult.trajectory = value
           }
      }
      @discardableResult
      public func setTrajectory(_ value:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb>) -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        self.trajectory = value
        return self
      }
      @discardableResult
      public func clearTrajectory() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        builderResult.trajectory.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoRequestPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoRequestPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoRequestPb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoRequestPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoRequestPb) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoRequestPb() {
         return self
        }
        if other.hasRequestId {
             requestId = other.requestId
        }
        if (other.hasData) {
            try mergeData(value: other.data)
        }
        if !other.trajectory.isEmpty  {
           builderResult.trajectory += other.trajectory
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            requestId = try codedInputStream.readInt32()

          case 18:
            let subBuilder:Duel.Pta.Api.PtaassistantResponsePb.Builder = Duel.Pta.Api.PtaassistantResponsePb.Builder()
            if hasData {
              try subBuilder.mergeFrom(other: data)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            data = subBuilder.buildPartial()

          case 26:
            let subBuilder = Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            trajectory.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoRequestPb.Builder()
        if let jsonValueRequestId = jsonMap["requestId"] as? Int {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)
        } else if let jsonValueRequestId = jsonMap["requestId"] as? String {
          resultDecodedBuilder.requestId = Int32(jsonValueRequestId)!
        }
        if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
          resultDecodedBuilder.data = try Duel.Pta.Api.PtaassistantResponsePb.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

        }
        if let jsonValueTrajectory = jsonMap["trajectory"] as? Array<Dictionary<String,Any>> {
          var jsonArrayTrajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb> = []
          for oneValueTrajectory in jsonValueTrajectory {
            let messageFromStringTrajectory = try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder.decodeToBuilder(jsonMap:oneValueTrajectory).build()

            jsonArrayTrajectory.append(messageFromStringTrajectory)
          }
          resultDecodedBuilder.trajectory = jsonArrayTrajectory
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoTrajectoryPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoTrajectoryPb, rhs: Duel.Pta.Api.PtaassistantDemoTrajectoryPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasTrajectoryId == rhs.hasTrajectoryId) && (!lhs.hasTrajectoryId || lhs.trajectoryId == rhs.trajectoryId)
      fieldCheck = fieldCheck && (lhs.trajectorySample == rhs.trajectorySample)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var trajectoryId:Int32 = Int32(0)
    public fileprivate(set) var hasTrajectoryId:Bool = false

    public fileprivate(set) var trajectorySample:Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb>  = Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasTrajectoryId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:trajectoryId)
      }
      for oneElementTrajectorySample in trajectorySample {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementTrajectorySample)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTrajectoryId {
        serialize_size += trajectoryId.computeInt32Size(fieldNumber: 1)
      }
      for oneElementTrajectorySample in trajectorySample {
          serialize_size += oneElementTrajectorySample.computeMessageSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryPb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoTrajectoryPb) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasTrajectoryId {
        jsonMap["trajectoryId"] = Int(trajectoryId)
      }
      if !trajectorySample.isEmpty {
        var jsonArrayTrajectorySample:Array<Dictionary<String,Any>> = []
          for oneValueTrajectorySample in trajectorySample {
            let ecodedMessageTrajectorySample = try oneValueTrajectorySample.encode()
            jsonArrayTrajectorySample.append(ecodedMessageTrajectorySample)
          }
        jsonMap["trajectorySample"] = jsonArrayTrajectorySample
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasTrajectoryId {
        output += "\(indent) trajectoryId: \(trajectoryId) \n"
      }
      var trajectorySampleElementIndex:Int = 0
      for oneElementTrajectorySample in trajectorySample {
          output += "\(indent) trajectorySample[\(trajectorySampleElementIndex)] {\n"
          output += try oneElementTrajectorySample.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          trajectorySampleElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTrajectoryId {
               hashCode = (hashCode &* 31) &+ trajectoryId.hashValue
            }
            for oneElementTrajectorySample in trajectorySample {
                hashCode = (hashCode &* 31) &+ oneElementTrajectorySample.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoTrajectoryPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoTrajectoryPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoTrajectoryPb = Duel.Pta.Api.PtaassistantDemoTrajectoryPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTrajectoryId:Bool {
           get {
                return builderResult.hasTrajectoryId
           }
      }
      public var trajectoryId:Int32 {
           get {
                return builderResult.trajectoryId
           }
           set (value) {
               builderResult.hasTrajectoryId = true
               builderResult.trajectoryId = value
           }
      }
      @discardableResult
      public func setTrajectoryId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        self.trajectoryId = value
        return self
      }
      @discardableResult
      public func clearTrajectoryId() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder{
           builderResult.hasTrajectoryId = false
           builderResult.trajectoryId = Int32(0)
           return self
      }
      public var trajectorySample:Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb> {
           get {
               return builderResult.trajectorySample
           }
           set (value) {
               builderResult.trajectorySample = value
           }
      }
      @discardableResult
      public func setTrajectorySample(_ value:Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb>) -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        self.trajectorySample = value
        return self
      }
      @discardableResult
      public func clearTrajectorySample() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        builderResult.trajectorySample.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoTrajectoryPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoTrajectoryPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoTrajectoryPb) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoTrajectoryPb() {
         return self
        }
        if other.hasTrajectoryId {
             trajectoryId = other.trajectoryId
        }
        if !other.trajectorySample.isEmpty  {
           builderResult.trajectorySample += other.trajectorySample
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            trajectoryId = try codedInputStream.readInt32()

          case 18:
            let subBuilder = Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            trajectorySample.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder()
        if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? Int {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)
        } else if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? String {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)!
        }
        if let jsonValueTrajectorySample = jsonMap["trajectorySample"] as? Array<Dictionary<String,Any>> {
          var jsonArrayTrajectorySample:Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb> = []
          for oneValueTrajectorySample in jsonValueTrajectorySample {
            let messageFromStringTrajectorySample = try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder.decodeToBuilder(jsonMap:oneValueTrajectorySample).build()

            jsonArrayTrajectorySample.append(messageFromStringTrajectorySample)
          }
          resultDecodedBuilder.trajectorySample = jsonArrayTrajectorySample
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoGpssamplePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoGpssamplePb, rhs: Duel.Pta.Api.PtaassistantDemoGpssamplePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSampleId == rhs.hasSampleId) && (!lhs.hasSampleId || lhs.sampleId == rhs.sampleId)
      fieldCheck = fieldCheck && (lhs.hasLat == rhs.hasLat) && (!lhs.hasLat || lhs.lat == rhs.lat)
      fieldCheck = fieldCheck && (lhs.hasLon == rhs.hasLon) && (!lhs.hasLon || lhs.lon == rhs.lon)
      fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var sampleId:Int32 = Int32(0)
    public fileprivate(set) var hasSampleId:Bool = false

    public fileprivate(set) var lat:Float = Float(0)
    public fileprivate(set) var hasLat:Bool = false

    public fileprivate(set) var lon:Float = Float(0)
    public fileprivate(set) var hasLon:Bool = false

    public fileprivate(set) var timestamp:Int64 = Int64(0)
    public fileprivate(set) var hasTimestamp:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSampleId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:sampleId)
      }
      if hasLat {
        try codedOutputStream.writeFloat(fieldNumber: 2, value:lat)
      }
      if hasLon {
        try codedOutputStream.writeFloat(fieldNumber: 3, value:lon)
      }
      if hasTimestamp {
        try codedOutputStream.writeInt64(fieldNumber: 4, value:timestamp)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSampleId {
        serialize_size += sampleId.computeInt32Size(fieldNumber: 1)
      }
      if hasLat {
        serialize_size += lat.computeFloatSize(fieldNumber: 2)
      }
      if hasLon {
        serialize_size += lon.computeFloatSize(fieldNumber: 3)
      }
      if hasTimestamp {
        serialize_size += timestamp.computeInt64Size(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
      return Duel.Pta.Api.PtaassistantDemoGpssamplePb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoGpssamplePb) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSampleId {
        jsonMap["sampleId"] = Int(sampleId)
      }
      if hasLat {
        jsonMap["lat"] = Float(lat)
      }
      if hasLon {
        jsonMap["lon"] = Float(lon)
      }
      if hasTimestamp {
        jsonMap["timestamp"] = "\(timestamp)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
      return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
      return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSampleId {
        output += "\(indent) sampleId: \(sampleId) \n"
      }
      if hasLat {
        output += "\(indent) lat: \(lat) \n"
      }
      if hasLon {
        output += "\(indent) lon: \(lon) \n"
      }
      if hasTimestamp {
        output += "\(indent) timestamp: \(timestamp) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSampleId {
               hashCode = (hashCode &* 31) &+ sampleId.hashValue
            }
            if hasLat {
               hashCode = (hashCode &* 31) &+ lat.hashValue
            }
            if hasLon {
               hashCode = (hashCode &* 31) &+ lon.hashValue
            }
            if hasTimestamp {
               hashCode = (hashCode &* 31) &+ timestamp.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoGpssamplePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoGpssamplePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoGpssamplePb = Duel.Pta.Api.PtaassistantDemoGpssamplePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSampleId:Bool {
           get {
                return builderResult.hasSampleId
           }
      }
      public var sampleId:Int32 {
           get {
                return builderResult.sampleId
           }
           set (value) {
               builderResult.hasSampleId = true
               builderResult.sampleId = value
           }
      }
      @discardableResult
      public func setSampleId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        self.sampleId = value
        return self
      }
      @discardableResult
      public func clearSampleId() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder{
           builderResult.hasSampleId = false
           builderResult.sampleId = Int32(0)
           return self
      }
      public var hasLat:Bool {
           get {
                return builderResult.hasLat
           }
      }
      public var lat:Float {
           get {
                return builderResult.lat
           }
           set (value) {
               builderResult.hasLat = true
               builderResult.lat = value
           }
      }
      @discardableResult
      public func setLat(_ value:Float) -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        self.lat = value
        return self
      }
      @discardableResult
      public func clearLat() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder{
           builderResult.hasLat = false
           builderResult.lat = Float(0)
           return self
      }
      public var hasLon:Bool {
           get {
                return builderResult.hasLon
           }
      }
      public var lon:Float {
           get {
                return builderResult.lon
           }
           set (value) {
               builderResult.hasLon = true
               builderResult.lon = value
           }
      }
      @discardableResult
      public func setLon(_ value:Float) -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        self.lon = value
        return self
      }
      @discardableResult
      public func clearLon() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder{
           builderResult.hasLon = false
           builderResult.lon = Float(0)
           return self
      }
      public var hasTimestamp:Bool {
           get {
                return builderResult.hasTimestamp
           }
      }
      public var timestamp:Int64 {
           get {
                return builderResult.timestamp
           }
           set (value) {
               builderResult.hasTimestamp = true
               builderResult.timestamp = value
           }
      }
      @discardableResult
      public func setTimestamp(_ value:Int64) -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        self.timestamp = value
        return self
      }
      @discardableResult
      public func clearTimestamp() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder{
           builderResult.hasTimestamp = false
           builderResult.timestamp = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoGpssamplePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoGpssamplePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoGpssamplePb) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoGpssamplePb() {
         return self
        }
        if other.hasSampleId {
             sampleId = other.sampleId
        }
        if other.hasLat {
             lat = other.lat
        }
        if other.hasLon {
             lon = other.lon
        }
        if other.hasTimestamp {
             timestamp = other.timestamp
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            sampleId = try codedInputStream.readInt32()

          case 21:
            lat = try codedInputStream.readFloat()

          case 29:
            lon = try codedInputStream.readFloat()

          case 32:
            timestamp = try codedInputStream.readInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
        if let jsonValueSampleId = jsonMap["sampleId"] as? Int {
          resultDecodedBuilder.sampleId = Int32(jsonValueSampleId)
        } else if let jsonValueSampleId = jsonMap["sampleId"] as? String {
          resultDecodedBuilder.sampleId = Int32(jsonValueSampleId)!
        }
        if let jsonValueLat = jsonMap["lat"] as? Float {
          resultDecodedBuilder.lat = Float(jsonValueLat)
        } else if let jsonValueLat = jsonMap["lat"] as? String {
          resultDecodedBuilder.lat = Float(jsonValueLat)!
        }
        if let jsonValueLon = jsonMap["lon"] as? Float {
          resultDecodedBuilder.lon = Float(jsonValueLon)
        } else if let jsonValueLon = jsonMap["lon"] as? String {
          resultDecodedBuilder.lon = Float(jsonValueLon)!
        }
        if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
          resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)!
        } else if let jsonValueTimestamp = jsonMap["timestamp"] as? Int {
          resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoResponsePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoResponsePb, rhs: Duel.Pta.Api.PtaassistantDemoResponsePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasDemoResponseId == rhs.hasDemoResponseId) && (!lhs.hasDemoResponseId || lhs.demoResponseId == rhs.demoResponseId)
      fieldCheck = fieldCheck && (lhs.trajectory == rhs.trajectory)
      fieldCheck = fieldCheck && (lhs.messages == rhs.messages)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var demoResponseId:Int32 = Int32(0)
    public fileprivate(set) var hasDemoResponseId:Bool = false

    public fileprivate(set) var trajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb>  = Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb>()
    public fileprivate(set) var messages:Array<Duel.Pta.Api.PtaassistantDemoMessagePb>  = Array<Duel.Pta.Api.PtaassistantDemoMessagePb>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasDemoResponseId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:demoResponseId)
      }
      for oneElementTrajectory in trajectory {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementTrajectory)
      }
      for oneElementMessages in messages {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementMessages)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDemoResponseId {
        serialize_size += demoResponseId.computeInt32Size(fieldNumber: 1)
      }
      for oneElementTrajectory in trajectory {
          serialize_size += oneElementTrajectory.computeMessageSize(fieldNumber: 2)
      }
      for oneElementMessages in messages {
          serialize_size += oneElementMessages.computeMessageSize(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
      return Duel.Pta.Api.PtaassistantDemoResponsePb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoResponsePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoResponsePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoResponsePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoResponsePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoResponsePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoResponsePb) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasDemoResponseId {
        jsonMap["demoResponseId"] = Int(demoResponseId)
      }
      if !trajectory.isEmpty {
        var jsonArrayTrajectory:Array<Dictionary<String,Any>> = []
          for oneValueTrajectory in trajectory {
            let ecodedMessageTrajectory = try oneValueTrajectory.encode()
            jsonArrayTrajectory.append(ecodedMessageTrajectory)
          }
        jsonMap["trajectory"] = jsonArrayTrajectory
      }
      if !messages.isEmpty {
        var jsonArrayMessages:Array<Dictionary<String,Any>> = []
          for oneValueMessages in messages {
            let ecodedMessageMessages = try oneValueMessages.encode()
            jsonArrayMessages.append(ecodedMessageMessages)
          }
        jsonMap["messages"] = jsonArrayMessages
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
      return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
      return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasDemoResponseId {
        output += "\(indent) demoResponseId: \(demoResponseId) \n"
      }
      var trajectoryElementIndex:Int = 0
      for oneElementTrajectory in trajectory {
          output += "\(indent) trajectory[\(trajectoryElementIndex)] {\n"
          output += try oneElementTrajectory.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          trajectoryElementIndex += 1
      }
      var messagesElementIndex:Int = 0
      for oneElementMessages in messages {
          output += "\(indent) messages[\(messagesElementIndex)] {\n"
          output += try oneElementMessages.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          messagesElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDemoResponseId {
               hashCode = (hashCode &* 31) &+ demoResponseId.hashValue
            }
            for oneElementTrajectory in trajectory {
                hashCode = (hashCode &* 31) &+ oneElementTrajectory.hashValue
            }
            for oneElementMessages in messages {
                hashCode = (hashCode &* 31) &+ oneElementMessages.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoResponsePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoResponsePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoResponsePb = Duel.Pta.Api.PtaassistantDemoResponsePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoResponsePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasDemoResponseId:Bool {
           get {
                return builderResult.hasDemoResponseId
           }
      }
      public var demoResponseId:Int32 {
           get {
                return builderResult.demoResponseId
           }
           set (value) {
               builderResult.hasDemoResponseId = true
               builderResult.demoResponseId = value
           }
      }
      @discardableResult
      public func setDemoResponseId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        self.demoResponseId = value
        return self
      }
      @discardableResult
      public func clearDemoResponseId() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder{
           builderResult.hasDemoResponseId = false
           builderResult.demoResponseId = Int32(0)
           return self
      }
      public var trajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb> {
           get {
               return builderResult.trajectory
           }
           set (value) {
               builderResult.trajectory = value
           }
      }
      @discardableResult
      public func setTrajectory(_ value:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb>) -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        self.trajectory = value
        return self
      }
      @discardableResult
      public func clearTrajectory() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        builderResult.trajectory.removeAll(keepingCapacity: false)
        return self
      }
      public var messages:Array<Duel.Pta.Api.PtaassistantDemoMessagePb> {
           get {
               return builderResult.messages
           }
           set (value) {
               builderResult.messages = value
           }
      }
      @discardableResult
      public func setMessages(_ value:Array<Duel.Pta.Api.PtaassistantDemoMessagePb>) -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        self.messages = value
        return self
      }
      @discardableResult
      public func clearMessages() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        builderResult.messages.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoResponsePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoResponsePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoResponsePb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoResponsePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoResponsePb) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoResponsePb() {
         return self
        }
        if other.hasDemoResponseId {
             demoResponseId = other.demoResponseId
        }
        if !other.trajectory.isEmpty  {
           builderResult.trajectory += other.trajectory
        }
        if !other.messages.isEmpty  {
           builderResult.messages += other.messages
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            demoResponseId = try codedInputStream.readInt32()

          case 18:
            let subBuilder = Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            trajectory.append(subBuilder.buildPartial())

          case 26:
            let subBuilder = Duel.Pta.Api.PtaassistantDemoMessagePb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            messages.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoResponsePb.Builder()
        if let jsonValueDemoResponseId = jsonMap["demoResponseId"] as? Int {
          resultDecodedBuilder.demoResponseId = Int32(jsonValueDemoResponseId)
        } else if let jsonValueDemoResponseId = jsonMap["demoResponseId"] as? String {
          resultDecodedBuilder.demoResponseId = Int32(jsonValueDemoResponseId)!
        }
        if let jsonValueTrajectory = jsonMap["trajectory"] as? Array<Dictionary<String,Any>> {
          var jsonArrayTrajectory:Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb> = []
          for oneValueTrajectory in jsonValueTrajectory {
            let messageFromStringTrajectory = try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder.decodeToBuilder(jsonMap:oneValueTrajectory).build()

            jsonArrayTrajectory.append(messageFromStringTrajectory)
          }
          resultDecodedBuilder.trajectory = jsonArrayTrajectory
        }
        if let jsonValueMessages = jsonMap["messages"] as? Array<Dictionary<String,Any>> {
          var jsonArrayMessages:Array<Duel.Pta.Api.PtaassistantDemoMessagePb> = []
          for oneValueMessages in jsonValueMessages {
            let messageFromStringMessages = try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder.decodeToBuilder(jsonMap:oneValueMessages).build()

            jsonArrayMessages.append(messageFromStringMessages)
          }
          resultDecodedBuilder.messages = jsonArrayMessages
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoMessagePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoMessagePb, rhs: Duel.Pta.Api.PtaassistantDemoMessagePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasMessageId == rhs.hasMessageId) && (!lhs.hasMessageId || lhs.messageId == rhs.messageId)
      fieldCheck = fieldCheck && (lhs.hasTrajectorySample == rhs.hasTrajectorySample) && (!lhs.hasTrajectorySample || lhs.trajectorySample == rhs.trajectorySample)
      fieldCheck = fieldCheck && (lhs.info == rhs.info)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var messageId:Int32 = Int32(0)
    public fileprivate(set) var hasMessageId:Bool = false

    public fileprivate(set) var trajectorySample:Duel.Pta.Api.PtaassistantDemoGpssamplePb!
    public fileprivate(set) var hasTrajectorySample:Bool = false
    public fileprivate(set) var info:Array<Duel.Pta.Api.PtaassistantDemoInfoPb>  = Array<Duel.Pta.Api.PtaassistantDemoInfoPb>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasMessageId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:messageId)
      }
      if hasTrajectorySample {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:trajectorySample)
      }
      for oneElementInfo in info {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementInfo)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMessageId {
        serialize_size += messageId.computeInt32Size(fieldNumber: 1)
      }
      if hasTrajectorySample {
          if let varSizetrajectorySample = trajectorySample?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizetrajectorySample
          }
      }
      for oneElementInfo in info {
          serialize_size += oneElementInfo.computeMessageSize(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
      return Duel.Pta.Api.PtaassistantDemoMessagePb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoMessagePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoMessagePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoMessagePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoMessagePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoMessagePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoMessagePb) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasMessageId {
        jsonMap["messageId"] = Int(messageId)
      }
      if hasTrajectorySample {
        jsonMap["trajectorySample"] = try trajectorySample.encode()
      }
      if !info.isEmpty {
        var jsonArrayInfo:Array<Dictionary<String,Any>> = []
          for oneValueInfo in info {
            let ecodedMessageInfo = try oneValueInfo.encode()
            jsonArrayInfo.append(ecodedMessageInfo)
          }
        jsonMap["info"] = jsonArrayInfo
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
      return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
      return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasMessageId {
        output += "\(indent) messageId: \(messageId) \n"
      }
      if hasTrajectorySample {
        output += "\(indent) trajectorySample {\n"
        if let outDescTrajectorySample = trajectorySample {
          output += try outDescTrajectorySample.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var infoElementIndex:Int = 0
      for oneElementInfo in info {
          output += "\(indent) info[\(infoElementIndex)] {\n"
          output += try oneElementInfo.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          infoElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessageId {
               hashCode = (hashCode &* 31) &+ messageId.hashValue
            }
            if hasTrajectorySample {
                if let hashValuetrajectorySample = trajectorySample?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetrajectorySample
                }
            }
            for oneElementInfo in info {
                hashCode = (hashCode &* 31) &+ oneElementInfo.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoMessagePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoMessagePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoMessagePb = Duel.Pta.Api.PtaassistantDemoMessagePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoMessagePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMessageId:Bool {
           get {
                return builderResult.hasMessageId
           }
      }
      public var messageId:Int32 {
           get {
                return builderResult.messageId
           }
           set (value) {
               builderResult.hasMessageId = true
               builderResult.messageId = value
           }
      }
      @discardableResult
      public func setMessageId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        self.messageId = value
        return self
      }
      @discardableResult
      public func clearMessageId() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder{
           builderResult.hasMessageId = false
           builderResult.messageId = Int32(0)
           return self
      }
      public var hasTrajectorySample:Bool {
           get {
               return builderResult.hasTrajectorySample
           }
      }
      public var trajectorySample:Duel.Pta.Api.PtaassistantDemoGpssamplePb! {
           get {
               if trajectorySampleBuilder_ != nil {
                  builderResult.trajectorySample = trajectorySampleBuilder_.getMessage()
               }
               return builderResult.trajectorySample
           }
           set (value) {
               builderResult.hasTrajectorySample = true
               builderResult.trajectorySample = value
           }
      }
      fileprivate var trajectorySampleBuilder_:Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder! {
           didSet {
              builderResult.hasTrajectorySample = true
           }
      }
      public func getTrajectorySampleBuilder() -> Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder {
        if trajectorySampleBuilder_ == nil {
           trajectorySampleBuilder_ = Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
           builderResult.trajectorySample = trajectorySampleBuilder_.getMessage()
           if trajectorySample != nil {
              try! trajectorySampleBuilder_.mergeFrom(other: trajectorySample)
           }
        }
        return trajectorySampleBuilder_
      }
      @discardableResult
      public func setTrajectorySample(_ value:Duel.Pta.Api.PtaassistantDemoGpssamplePb!) -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        self.trajectorySample = value
        return self
      }
      @discardableResult
      public func mergeTrajectorySample(value:Duel.Pta.Api.PtaassistantDemoGpssamplePb) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        if builderResult.hasTrajectorySample {
          builderResult.trajectorySample = try Duel.Pta.Api.PtaassistantDemoGpssamplePb.builderWithPrototype(prototype:builderResult.trajectorySample).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.trajectorySample = value
        }
        builderResult.hasTrajectorySample = true
        return self
      }
      @discardableResult
      public func clearTrajectorySample() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        trajectorySampleBuilder_ = nil
        builderResult.hasTrajectorySample = false
        builderResult.trajectorySample = nil
        return self
      }
      public var info:Array<Duel.Pta.Api.PtaassistantDemoInfoPb> {
           get {
               return builderResult.info
           }
           set (value) {
               builderResult.info = value
           }
      }
      @discardableResult
      public func setInfo(_ value:Array<Duel.Pta.Api.PtaassistantDemoInfoPb>) -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        self.info = value
        return self
      }
      @discardableResult
      public func clearInfo() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        builderResult.info.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoMessagePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoMessagePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoMessagePb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoMessagePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoMessagePb) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoMessagePb() {
         return self
        }
        if other.hasMessageId {
             messageId = other.messageId
        }
        if (other.hasTrajectorySample) {
            try mergeTrajectorySample(value: other.trajectorySample)
        }
        if !other.info.isEmpty  {
           builderResult.info += other.info
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            messageId = try codedInputStream.readInt32()

          case 18:
            let subBuilder:Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder = Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder()
            if hasTrajectorySample {
              try subBuilder.mergeFrom(other: trajectorySample)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            trajectorySample = subBuilder.buildPartial()

          case 26:
            let subBuilder = Duel.Pta.Api.PtaassistantDemoInfoPb.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            info.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoMessagePb.Builder()
        if let jsonValueMessageId = jsonMap["messageId"] as? Int {
          resultDecodedBuilder.messageId = Int32(jsonValueMessageId)
        } else if let jsonValueMessageId = jsonMap["messageId"] as? String {
          resultDecodedBuilder.messageId = Int32(jsonValueMessageId)!
        }
        if let jsonValueTrajectorySample = jsonMap["trajectorySample"] as? Dictionary<String,Any> {
          resultDecodedBuilder.trajectorySample = try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder.decodeToBuilder(jsonMap:jsonValueTrajectorySample).build()

        }
        if let jsonValueInfo = jsonMap["info"] as? Array<Dictionary<String,Any>> {
          var jsonArrayInfo:Array<Duel.Pta.Api.PtaassistantDemoInfoPb> = []
          for oneValueInfo in jsonValueInfo {
            let messageFromStringInfo = try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder.decodeToBuilder(jsonMap:oneValueInfo).build()

            jsonArrayInfo.append(messageFromStringInfo)
          }
          resultDecodedBuilder.info = jsonArrayInfo
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoInfoPb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoInfoPb, rhs: Duel.Pta.Api.PtaassistantDemoInfoPb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
      fieldCheck = fieldCheck && (lhs.hasMessageType == rhs.hasMessageType) && (!lhs.hasMessageType || lhs.messageType == rhs.messageType)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var message:String = ""
    public fileprivate(set) var hasMessage:Bool = false

    public fileprivate(set) var messageType:Duel.Pta.Api.DemoMessageType = Duel.Pta.Api.DemoMessageType.report
    public fileprivate(set) var hasMessageType:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasMessage {
        try codedOutputStream.writeString(fieldNumber: 1, value:message)
      }
      if hasMessageType {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:messageType.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMessage {
        serialize_size += message.computeStringSize(fieldNumber: 1)
      }
      if (hasMessageType) {
        serialize_size += messageType.rawValue.computeEnumSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
      return Duel.Pta.Api.PtaassistantDemoInfoPb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoInfoPb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoInfoPb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoInfoPb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoInfoPb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoInfoPb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoInfoPb) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasMessage {
        jsonMap["message"] = message
      }
      if hasMessageType {
        jsonMap["messageType"] = messageType.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
      return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
      return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasMessage {
        output += "\(indent) message: \(message) \n"
      }
      if (hasMessageType) {
        output += "\(indent) messageType: \(messageType.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessage {
               hashCode = (hashCode &* 31) &+ message.hashValue
            }
            if hasMessageType {
               hashCode = (hashCode &* 31) &+ Int(messageType.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoInfoPb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoInfoPb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoInfoPb = Duel.Pta.Api.PtaassistantDemoInfoPb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoInfoPb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasMessage:Bool {
           get {
                return builderResult.hasMessage
           }
      }
      public var message:String {
           get {
                return builderResult.message
           }
           set (value) {
               builderResult.hasMessage = true
               builderResult.message = value
           }
      }
      @discardableResult
      public func setMessage(_ value:String) -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        self.message = value
        return self
      }
      @discardableResult
      public func clearMessage() -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder{
           builderResult.hasMessage = false
           builderResult.message = ""
           return self
      }
        public var hasMessageType:Bool{
            get {
                return builderResult.hasMessageType
            }
        }
        public var messageType:Duel.Pta.Api.DemoMessageType {
            get {
                return builderResult.messageType
            }
            set (value) {
                builderResult.hasMessageType = true
                builderResult.messageType = value
            }
        }
      @discardableResult
        public func setMessageType(_ value:Duel.Pta.Api.DemoMessageType) -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
          self.messageType = value
          return self
        }
      @discardableResult
        public func clearMessageType() -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
           builderResult.hasMessageType = false
           builderResult.messageType = .report
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoInfoPb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoInfoPb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoInfoPb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoInfoPb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoInfoPb) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoInfoPb() {
         return self
        }
        if other.hasMessage {
             message = other.message
        }
        if other.hasMessageType {
             messageType = other.messageType
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            message = try codedInputStream.readString()

          case 16:
            let valueIntmessageType = try codedInputStream.readEnum()
            if let enumsmessageType = Duel.Pta.Api.DemoMessageType(rawValue:valueIntmessageType){
                 messageType = enumsmessageType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntmessageType))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoInfoPb.Builder()
        if let jsonValueMessage = jsonMap["message"] as? String {
          resultDecodedBuilder.message = jsonValueMessage
        }
        if let jsonValueMessageType = jsonMap["messageType"] as? String {
          resultDecodedBuilder.messageType = try Duel.Pta.Api.DemoMessageType.fromString(str: jsonValueMessageType)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PtaassistantDemoTrajectoryResponsePb : GeneratedMessage {

    public static func == (lhs: Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb, rhs: Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasTrajectoryId == rhs.hasTrajectoryId) && (!lhs.hasTrajectoryId || lhs.trajectoryId == rhs.trajectoryId)
      fieldCheck = fieldCheck && (lhs.messageIds == rhs.messageIds)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var trajectoryId:Int32 = Int32(0)
    public fileprivate(set) var hasTrajectoryId:Bool = false

    public fileprivate(set) var messageIds:Array<Int32> = Array<Int32>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasTrajectoryId {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:trajectoryId)
      }
      if !messageIds.isEmpty {
        for oneValuemessageIds in messageIds {
          try codedOutputStream.writeInt32(fieldNumber: 2, value:oneValuemessageIds)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasTrajectoryId {
        serialize_size += trajectoryId.computeInt32Size(fieldNumber: 1)
      }
      var dataSizeMessageIds:Int32 = 0
      for oneValuemessageIds in messageIds {
          dataSizeMessageIds += oneValuemessageIds.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeMessageIds
      serialize_size += 1 * Int32(messageIds.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.classBuilder() as! Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder
    }
    public func getBuilder() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
      return classBuilder() as! Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder()
    }
    public func toBuilder() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasTrajectoryId {
        jsonMap["trajectoryId"] = Int(trajectoryId)
      }
      if !messageIds.isEmpty {
        var jsonArrayMessageIds:Array<Int> = []
          for oneValueMessageIds in messageIds {
            jsonArrayMessageIds.append(Int(oneValueMessageIds))
          }
        jsonMap["messageIds"] = jsonArrayMessageIds
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
      return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasTrajectoryId {
        output += "\(indent) trajectoryId: \(trajectoryId) \n"
      }
      var messageIdsElementIndex:Int = 0
      for oneValueMessageIds in messageIds  {
          output += "\(indent) messageIds[\(messageIdsElementIndex)]: \(oneValueMessageIds)\n"
          messageIdsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTrajectoryId {
               hashCode = (hashCode &* 31) &+ trajectoryId.hashValue
            }
            for oneValueMessageIds in messageIds {
                hashCode = (hashCode &* 31) &+ oneValueMessageIds.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb"
    }
    override public func className() -> String {
        return "Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb = Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb()
      public func getMessage() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasTrajectoryId:Bool {
           get {
                return builderResult.hasTrajectoryId
           }
      }
      public var trajectoryId:Int32 {
           get {
                return builderResult.trajectoryId
           }
           set (value) {
               builderResult.hasTrajectoryId = true
               builderResult.trajectoryId = value
           }
      }
      @discardableResult
      public func setTrajectoryId(_ value:Int32) -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        self.trajectoryId = value
        return self
      }
      @discardableResult
      public func clearTrajectoryId() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder{
           builderResult.hasTrajectoryId = false
           builderResult.trajectoryId = Int32(0)
           return self
      }
      public var messageIds:Array<Int32> {
           get {
               return builderResult.messageIds
           }
           set (array) {
               builderResult.messageIds = array
           }
      }
      @discardableResult
      public func setMessageIds(_ value:Array<Int32>) -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        self.messageIds = value
        return self
      }
      @discardableResult
      public func clearMessageIds() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
         builderResult.messageIds.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        builderResult = Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb()
        return self
      }
      override public func clone() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
        let returnMe:Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        if other == Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb() {
         return self
        }
        if other.hasTrajectoryId {
             trajectoryId = other.trajectoryId
        }
        if !other.messageIds.isEmpty {
            builderResult.messageIds += other.messageIds
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            trajectoryId = try codedInputStream.readInt32()

          case 16:
            messageIds += [try codedInputStream.readInt32()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        let resultDecodedBuilder = Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder()
        if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? Int {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)
        } else if let jsonValueTrajectoryId = jsonMap["trajectoryId"] as? String {
          resultDecodedBuilder.trajectoryId = Int32(jsonValueTrajectoryId)!
        }
        if let jsonValueMessageIds = jsonMap["messageIds"] as? Array<Int> {
          var jsonArrayMessageIds:Array<Int32> = []
          for oneValueMessageIds in jsonValueMessageIds {
            jsonArrayMessageIds.append(Int32(oneValueMessageIds))
          }
          resultDecodedBuilder.messageIds = jsonArrayMessageIds
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Duel.Pta.Api.PtaassistantRequestPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantRequestPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantRequestPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantRequestPb? {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantRequestPb {
    return try Duel.Pta.Api.PtaassistantRequestPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantTrajectoryPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantTrajectoryPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantTrajectoryPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb? {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantTrajectoryPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantResponsePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantResponsePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantResponsePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantResponsePb? {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantResponsePb {
    return try Duel.Pta.Api.PtaassistantResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantSegmentPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantSegmentPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantSegmentPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantSegmentPb? {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantSegmentPb {
    return try Duel.Pta.Api.PtaassistantSegmentPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantNodePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantNodePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantNodePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantNodePb? {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantNodePb {
    return try Duel.Pta.Api.PtaassistantNodePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantEdgePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantEdgePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantEdgePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantEdgePb? {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEdgePb {
    return try Duel.Pta.Api.PtaassistantEdgePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantEventPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantEventPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantEventPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantEventPb? {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantEventPb {
    return try Duel.Pta.Api.PtaassistantEventPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantLosEventPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantLosEventPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantLosEventPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLosEventPb? {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLosEventPb {
    return try Duel.Pta.Api.PtaassistantLosEventPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantLodPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantLodPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantLodPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLodPb? {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLodPb {
    return try Duel.Pta.Api.PtaassistantLodPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantLoslistPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantLoslistPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantLoslistPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLoslistPb? {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantLoslistPb {
    return try Duel.Pta.Api.PtaassistantLoslistPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantPathPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantPathPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantPathPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantPathPb? {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantPathPb {
    return try Duel.Pta.Api.PtaassistantPathPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantUseCasePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantUseCasePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantUseCasePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantUseCasePb? {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantUseCasePb {
    return try Duel.Pta.Api.PtaassistantUseCasePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoRequestPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoRequestPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoRequestPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb? {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoRequestPb {
    return try Duel.Pta.Api.PtaassistantDemoRequestPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoTrajectoryPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoTrajectoryPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb? {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryPb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoGpssamplePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoGpssamplePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb? {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoGpssamplePb {
    return try Duel.Pta.Api.PtaassistantDemoGpssamplePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoResponsePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoResponsePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoResponsePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb? {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoMessagePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoMessagePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoMessagePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb? {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoMessagePb {
    return try Duel.Pta.Api.PtaassistantDemoMessagePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoInfoPb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoInfoPb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoInfoPb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb? {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoInfoPb {
    return try Duel.Pta.Api.PtaassistantDemoInfoPb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb> {
    var mergedArray = Array<Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb? {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(data: data, extensionRegistry:Duel.Pta.Api.PtaassistantRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb {
    return try Duel.Pta.Api.PtaassistantDemoTrajectoryResponsePb.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
